<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PythyBird - Navigate the Markets</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Solana Web3.js for blockchain integration -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0a0f;
      --bg-card: #12121a;
      --accent-green: #00ff88;
      --accent-red: #ff3366;
      --accent-purple: #8b5cf6;
      --text-primary: #ffffff;
      --text-secondary: #6b7280;
      --grid-color: rgba(139, 92, 246, 0.1);
    }

    body {
      font-family: 'Space Mono', monospace;
      background: var(--bg-dark);
      color: var(--text-primary);
      min-height: 100vh;
      overflow: hidden;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: 
        linear-gradient(180deg, rgba(139, 92, 246, 0.05) 0%, transparent 50%),
        repeating-linear-gradient(90deg, var(--grid-color) 0px, var(--grid-color) 1px, transparent 1px, transparent 60px),
        repeating-linear-gradient(0deg, var(--grid-color) 0px, var(--grid-color) 1px, transparent 1px, transparent 60px);
    }

    header {
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(139, 92, 246, 0.2);
      background: rgba(18, 18, 26, 0.8);
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 100;
    }

    .logo {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      font-weight: 900;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .logo span {
      color: var(--text-secondary);
      -webkit-text-fill-color: var(--text-secondary);
      font-weight: 400;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .feed-selector {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .feed-selector label {
      color: var(--text-secondary);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .feed-selector select {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--text-primary);
      padding: 0.5rem 1rem;
      font-family: 'Space Mono', monospace;
      font-size: 0.9rem;
      border-radius: 4px;
      cursor: pointer;
      outline: none;
      transition: border-color 0.2s;
    }

    .feed-selector select:hover,
    .feed-selector select:focus {
      border-color: var(--accent-purple);
    }

    /* Feed Discovery System */
    .feed-discovery {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      position: relative;
    }

    .feed-search {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--text-primary);
      padding: 0.5rem 1rem;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      border-radius: 4px;
      outline: none;
      width: 180px;
      transition: border-color 0.2s, width 0.2s;
    }

    .feed-search:focus {
      border-color: var(--accent-purple);
      width: 220px;
    }

    .feed-search::placeholder {
      color: var(--text-secondary);
    }

    .asset-class-container {
      position: relative;
    }

    .asset-class-btn {
      background: #e8e4df;
      border: none;
      color: #1a1a2e;
      padding: 0.5rem 1rem;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background 0.2s;
    }

    .asset-class-btn:hover {
      background: #d4d0cb;
    }

    .asset-class-btn::after {
      content: '‚ñº';
      font-size: 0.6rem;
    }

    .asset-class-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      min-width: 220px;
      z-index: 100;
      display: none;
      overflow: hidden;
    }

    .asset-class-dropdown.open {
      display: block;
    }

    .asset-class-dropdown-header {
      padding: 0.75rem 1rem;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6b7280;
      border-bottom: 1px solid #e5e7eb;
    }

    .asset-class-option {
      padding: 0.6rem 1rem;
      font-size: 0.85rem;
      color: #1a1a2e;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background 0.15s;
    }

    .asset-class-option:hover {
      background: #f3f4f6;
    }

    .asset-class-option.selected {
      background: #f3f4f6;
    }

    .asset-class-option.selected::after {
      content: '‚úì';
      color: var(--accent-purple);
      font-weight: bold;
    }

    .selected-feed-display {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--accent-green);
      padding: 0.5rem 1rem;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.85rem;
      font-weight: 700;
      border-radius: 4px;
      min-width: 120px;
      text-align: center;
    }

    .feed-results-container {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 4px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 99;
      min-width: 300px;
      display: none;
    }

    .feed-results-container.open {
      display: block;
    }

    .feed-results-container::-webkit-scrollbar {
      width: 6px;
    }

    .feed-results-container::-webkit-scrollbar-track {
      background: var(--bg-dark);
    }

    .feed-results-container::-webkit-scrollbar-thumb {
      background: var(--accent-purple);
      border-radius: 3px;
    }

    .feed-result-item {
      padding: 0.6rem 1rem;
      cursor: pointer;
      border-bottom: 1px solid rgba(139, 92, 246, 0.1);
      transition: background 0.15s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .feed-result-item:hover {
      background: rgba(139, 92, 246, 0.15);
    }

    .feed-result-item:last-child {
      border-bottom: none;
    }

    .feed-result-symbol {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .feed-result-class {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      background: rgba(139, 92, 246, 0.2);
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
    }

    .feed-loading {
      padding: 1rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.8rem;
    }

    .feed-no-results {
      padding: 1rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.8rem;
    }

    .main-content {
      flex: 1;
      display: flex;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
    }

    .game-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .stats-bar {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .stat-card {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.2);
      padding: 0.75rem 1.25rem;
      border-radius: 4px;
      min-width: 150px;
    }

    .stat-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }

    .stat-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.25rem;
      font-weight: 700;
    }

    .stat-value.price {
      color: var(--accent-green);
    }

    .stat-value.score {
      color: var(--accent-purple);
    }

    .stat-value.distance {
      color: var(--text-primary);
    }

    .price-change {
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .price-change.up {
      color: var(--accent-green);
    }

    .price-change.down {
      color: var(--accent-red);
    }

    .game-container {
      flex: 1;
      position: relative;
      background: #0a0a0f;
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #gameCanvas {
      display: block;
      /* Dimensions set by JavaScript for fixed virtual resolution */
      /* CSS scales the canvas while maintaining aspect ratio */
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(10, 10, 15, 0.9);
      backdrop-filter: blur(5px);
      z-index: 10;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .overlay p {
      color: var(--text-secondary);
      margin-bottom: 2rem;
      text-align: center;
      max-width: 400px;
      line-height: 1.6;
    }

    .start-btn {
      background: linear-gradient(135deg, var(--accent-purple), #6d28d9);
      border: none;
      color: white;
      padding: 1rem 3rem;
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
    }

    .game-over-stats {
      display: flex;
      gap: 2rem;
      margin: 1.5rem 0;
    }

    .game-over-stat {
      text-align: center;
    }

    .game-over-stat .label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
    }

    .game-over-stat .value {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-green);
    }

    .side-panel {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .panel-card {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 4px;
      padding: 1rem;
    }

    .panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--accent-purple);
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(139, 92, 246, 0.2);
    }

    .price-history {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .price-history::-webkit-scrollbar {
      width: 4px;
    }

    .price-history::-webkit-scrollbar-track {
      background: var(--bg-dark);
    }

    .price-history::-webkit-scrollbar-thumb {
      background: var(--accent-purple);
      border-radius: 2px;
    }

    .price-entry {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      padding: 0.25rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .price-entry .time {
      color: var(--text-secondary);
    }

    .price-entry .price {
      font-family: 'Orbitron', sans-serif;
    }

    .price-entry.up .price {
      color: var(--accent-green);
    }

    .price-entry.down .price {
      color: var(--accent-red);
    }

    .instructions {
      font-size: 0.8rem;
      line-height: 1.8;
      color: var(--text-secondary);
    }

    .instructions strong {
      color: var(--text-primary);
    }

    .instructions kbd {
      background: rgba(139, 92, 246, 0.2);
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      font-family: 'Space Mono', monospace;
      color: var(--accent-purple);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-red);
    }

    .status-dot.connected {
      background: var(--accent-green);
      box-shadow: 0 0 10px var(--accent-green);
    }

    .leaderboard {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: rgba(139, 92, 246, 0.05);
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .leaderboard-entry .rank {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(139, 92, 246, 0.2);
      border-radius: 50%;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      color: var(--accent-purple);
    }

    .leaderboard-entry .score {
      font-family: 'Orbitron', sans-serif;
      color: var(--accent-green);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .loading {
      animation: pulse 1.5s infinite;
    }

    @media (max-width: 900px) {
      .side-panel {
        display: none;
      }

      .main-content {
        padding: 0.5rem;
      }

      header {
        padding: 0.75rem 1rem;
        flex-direction: column;
        gap: 0.5rem;
      }
    }

    /* Wallet Button Styles */
    .wallet-section {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .wallet-address {
      font-family: 'Space Mono', monospace;
      font-size: 0.75rem;
      color: var(--accent-green);
      background: rgba(0, 255, 136, 0.1);
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      border: 1px solid rgba(0, 255, 136, 0.3);
    }

    .wallet-btn {
      background: linear-gradient(135deg, #AB9FF2, #8b5cf6);
      border: none;
      color: white;
      padding: 0.5rem 1rem;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .wallet-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 20px rgba(139, 92, 246, 0.3);
    }

    .wallet-btn.connected {
      background: linear-gradient(135deg, #00ff88, #00cc6a);
    }

    .wallet-btn.small {
      padding: 0.4rem 0.75rem;
      font-size: 0.65rem;
    }

    /* Leaderboard Styles */
    .panel-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .leaderboard-filter {
      display: flex;
      gap: 0.25rem;
    }

    .filter-btn {
      background: transparent;
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--text-secondary);
      padding: 0.25rem 0.5rem;
      font-family: 'Space Mono', monospace;
      font-size: 0.6rem;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .filter-btn:hover,
    .filter-btn.active {
      background: rgba(139, 92, 246, 0.2);
      color: var(--accent-purple);
      border-color: var(--accent-purple);
    }

    .leaderboard-entry {
      display: grid;
      grid-template-columns: 28px 1fr auto;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      background: rgba(139, 92, 246, 0.05);
      border-radius: 4px;
      font-size: 0.75rem;
      margin-bottom: 0.4rem;
    }

    .leaderboard-entry.highlight {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid rgba(0, 255, 136, 0.3);
    }

    .leaderboard-entry .rank {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(139, 92, 246, 0.2);
      border-radius: 50%;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.65rem;
      color: var(--accent-purple);
    }

    .leaderboard-entry .rank.gold {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #1a1a2e;
    }

    .leaderboard-entry .rank.silver {
      background: linear-gradient(135deg, #C0C0C0, #A0A0A0);
      color: #1a1a2e;
    }

    .leaderboard-entry .rank.bronze {
      background: linear-gradient(135deg, #CD7F32, #8B4513);
      color: #1a1a2e;
    }

    .leaderboard-entry .address {
      font-family: 'Space Mono', monospace;
      color: var(--text-secondary);
      font-size: 0.7rem;
    }

    .leaderboard-entry .score {
      font-family: 'Orbitron', sans-serif;
      color: var(--accent-green);
      font-weight: 700;
    }

    .leaderboard-loading,
    .leaderboard-empty {
      text-align: center;
      color: var(--text-secondary);
      padding: 1rem;
      font-size: 0.8rem;
    }

    .personal-best {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(139, 92, 246, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .personal-best-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .personal-best-score {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: var(--accent-green);
      font-weight: 700;
    }

    /* Submit score section */
    .submit-score-section {
      margin-top: 1rem;
      padding: 0.75rem;
      background: rgba(139, 92, 246, 0.1);
      border-radius: 4px;
    }

    .submit-status {
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-align: center;
      margin: 0;
    }

    .submit-status.success {
      color: var(--accent-green);
    }

    .submit-status.error {
      color: var(--accent-red);
    }

    .connect-prompt {
      margin-top: 1rem;
      text-align: center;
    }

    .connect-prompt p {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    /* Player Count */
    .player-count {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      background: rgba(139, 92, 246, 0.1);
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      border: 1px solid rgba(139, 92, 246, 0.3);
    }

    .player-count-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--accent-purple);
    }

    .player-count-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Multiplayer Menu Styles */
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin: 1.5rem 0;
    }

    .menu-btn {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--text-primary);
      padding: 1rem 2rem;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 250px;
    }

    .menu-btn:hover {
      background: rgba(139, 92, 246, 0.2);
      border-color: var(--accent-purple);
      transform: translateY(-2px);
    }

    .menu-btn.primary {
      background: linear-gradient(135deg, var(--accent-purple), #6d28d9);
      border: none;
      color: white;
    }

    .menu-btn.primary:hover {
      box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
    }

    .multiplayer-submenu {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
      padding: 0.75rem;
      background: rgba(139, 92, 246, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(139, 92, 246, 0.2);
    }

    .multiplayer-submenu.hidden {
      display: none;
    }

    .menu-btn.sub {
      min-width: unset;
      padding: 0.75rem 1.5rem;
      font-size: 0.8rem;
      background: transparent;
      border: 1px solid rgba(139, 92, 246, 0.3);
    }

    .menu-btn.sub:hover {
      background: rgba(139, 92, 246, 0.2);
    }

    /* Modal Styles */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }

    .modal-backdrop.hidden {
      display: none;
    }

    .modal {
      background: var(--bg-card);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 8px;
      padding: 2rem;
      min-width: 350px;
      max-width: 90%;
    }

    .modal h3 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.25rem;
      color: var(--accent-purple);
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .modal input[type="text"] {
      width: 100%;
      background: var(--bg-dark);
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--text-primary);
      padding: 0.75rem 1rem;
      font-family: 'Space Mono', monospace;
      font-size: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
      outline: none;
    }

    .modal input[type="text"]:focus {
      border-color: var(--accent-purple);
    }

    .modal input[type="text"]::placeholder {
      color: var(--text-secondary);
    }

    .modal-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .modal-checkbox input {
      width: 18px;
      height: 18px;
      accent-color: var(--accent-purple);
    }

    .modal-buttons {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .modal-btn {
      flex: 1;
      padding: 0.75rem 1rem;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-btn.primary {
      background: linear-gradient(135deg, var(--accent-purple), #6d28d9);
      border: none;
      color: white;
    }

    .modal-btn.ready {
      background: transparent;
      border: 2px solid var(--accent-green);
      color: var(--accent-green);
      transition: all 0.2s ease;
    }

    .modal-btn.ready:hover {
      background: rgba(0, 255, 136, 0.1);
    }

    .modal-btn.ready.is-ready {
      background: var(--accent-green);
      color: #0a0a0f;
      font-weight: bold;
    }

    .ready-status {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin: 0.5rem 0;
    }

    .ready-status.all-ready {
      color: var(--accent-green);
      font-weight: bold;
    }

    .modal-btn.secondary {
      background: transparent;
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: var(--text-secondary);
    }

    .modal-btn:hover {
      transform: translateY(-1px);
    }

    /* Lobby Browser Styles */
    .lobby-list {
      max-height: 300px;
      overflow-y: auto;
      margin: 1rem 0;
    }

    .lobby-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: rgba(139, 92, 246, 0.05);
      border: 1px solid rgba(139, 92, 246, 0.1);
      border-radius: 4px;
      margin-bottom: 0.5rem;
    }

    .lobby-item:hover {
      background: rgba(139, 92, 246, 0.1);
      border-color: rgba(139, 92, 246, 0.3);
    }

    .lobby-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .lobby-name {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    .lobby-meta {
      display: flex;
      gap: 1rem;
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .lobby-players {
      color: var(--accent-green);
    }

    .join-btn {
      background: linear-gradient(135deg, var(--accent-green), #00cc6a);
      border: none;
      color: #1a1a2e;
      padding: 0.5rem 1rem;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.7rem;
      font-weight: 700;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .join-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
    }

    .no-lobbies {
      text-align: center;
      color: var(--text-secondary);
      padding: 2rem;
      font-size: 0.85rem;
    }

    /* Waiting Room Styles */
    .lobby-code-display {
      text-align: center;
      margin: 1rem 0;
    }

    .lobby-code-display .label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .lobby-code-display .code {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-purple);
      letter-spacing: 0.2em;
      margin-top: 0.25rem;
    }

    .player-slots {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
      margin: 1.5rem 0;
      max-width: 400px;
    }

    .player-slot {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: rgba(139, 92, 246, 0.05);
      border: 2px solid rgba(139, 92, 246, 0.2);
      border-radius: 4px;
      min-height: 60px;
    }

    .player-slot.occupied {
      border-color: var(--accent-purple);
    }

    .player-slot.ready {
      border-color: var(--accent-green);
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    .player-slot .ready-badge {
      font-size: 0.6rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      margin-left: 0.5rem;
    }

    .player-slot .ready-badge.is-ready {
      background: var(--accent-green);
      color: #0a0a0f;
    }

    .player-slot .ready-badge.afk {
      background: rgba(255, 107, 107, 0.3);
      color: #ff6b6b;
    }

    .player-slot .slot-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .player-slot .slot-info {
      flex: 1;
    }

    .player-slot .slot-address {
      font-family: 'Space Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-primary);
    }

    .player-slot .slot-waiting {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .player-slot .host-badge {
      font-size: 0.6rem;
      background: var(--accent-purple);
      color: white;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .waiting-info {
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.8rem;
      margin: 1rem 0;
    }

    /* Results Screen Styles */
    .results-podium {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 0.5rem;
      margin: 2rem 0;
    }

    .podium-place {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      border-radius: 4px;
      min-width: 100px;
    }

    .podium-place.first {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
      border: 2px solid gold;
      order: 2;
      padding-bottom: 2rem;
    }

    .podium-place.second {
      background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(160, 160, 160, 0.2));
      border: 2px solid silver;
      order: 1;
    }

    .podium-place.third {
      background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(139, 69, 19, 0.2));
      border: 2px solid #cd7f32;
      order: 3;
    }

    .podium-place .place-num {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
    }

    .podium-place.first .place-num { color: gold; }
    .podium-place.second .place-num { color: silver; }
    .podium-place.third .place-num { color: #cd7f32; }

    .podium-place .place-address {
      font-family: 'Space Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-secondary);
      margin: 0.5rem 0;
    }

    .podium-place .place-score {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      color: var(--accent-green);
    }

    .crown {
      font-size: 1.5rem;
      margin-bottom: 0.25rem;
    }

    /* Countdown Overlay */
    .countdown-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(10, 10, 15, 0.8);
      z-index: 15;
    }

    .countdown-overlay.hidden {
      display: none;
    }

    .countdown-number {
      font-family: 'Orbitron', sans-serif;
      font-size: 8rem;
      font-weight: 900;
      color: var(--accent-purple);
      text-shadow: 0 0 50px rgba(139, 92, 246, 0.5);
      animation: countdownPulse 1s ease-out;
    }

    .countdown-number.go {
      color: var(--accent-green);
      text-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
    }

    @keyframes countdownPulse {
      0% { transform: scale(1.5); opacity: 0; }
      50% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0.8); opacity: 0; }
    }

    /* Elimination Toast */
    .elimination-toast {
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 51, 102, 0.9);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.85rem;
      z-index: 100;
      animation: toastSlide 3s ease-out forwards;
    }

    @keyframes toastSlide {
      0% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
      10% { transform: translateX(-50%) translateY(0); opacity: 1; }
      90% { transform: translateX(-50%) translateY(0); opacity: 1; }
      100% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
    }

    /* Multiplayer player indicators */
    .mp-player-list {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 5;
    }

    .mp-player-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.75rem;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 4px;
      font-size: 0.7rem;
    }

    .mp-player-indicator.eliminated {
      opacity: 0.5;
      text-decoration: line-through;
    }

    .mp-player-indicator .color-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .mp-player-indicator .mp-address {
      font-family: 'Space Mono', monospace;
      color: var(--text-secondary);
    }

    .mp-player-indicator .mp-score {
      font-family: 'Orbitron', sans-serif;
      color: var(--accent-green);
      margin-left: auto;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header>
      <div class="logo">PythyBird <span>Navigate the Markets</span></div>
      <div class="feed-discovery">
        <input type="text" class="feed-search" id="feedSearch" placeholder="Search symbols..." autocomplete="off">
        <div class="asset-class-container">
          <button class="asset-class-btn" id="assetClassBtn">Asset Class</button>
          <div class="asset-class-dropdown" id="assetClassDropdown">
            <div class="asset-class-dropdown-header">Asset Class</div>
            <div class="asset-class-option selected" data-class="all">All</div>
            <div class="asset-class-option" data-class="commodities">Commodities</div>
            <div class="asset-class-option" data-class="crypto">Crypto</div>
            <div class="asset-class-option" data-class="crypto_index">Crypto Index</div>
            <div class="asset-class-option" data-class="crypto_nav">Crypto NAV</div>
            <div class="asset-class-option" data-class="crypto_redemption_rate">Crypto Redemption Rate</div>
            <div class="asset-class-option" data-class="eco">ECO</div>
            <div class="asset-class-option" data-class="equity">Equity</div>
            <div class="asset-class-option" data-class="fx">FX</div>
            <div class="asset-class-option" data-class="kalshi">Kalshi</div>
            <div class="asset-class-option" data-class="metal">Metal</div>
            <div class="asset-class-option" data-class="rates">Rates</div>
          </div>
        </div>
        <div class="selected-feed-display" id="selectedFeedDisplay">BTC/USD</div>
        <div class="feed-results-container" id="feedResults"></div>
      </div>
      <div class="connection-status">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Connecting...</span>
      </div>
      <div class="player-count">
        <span class="player-count-value" id="playerCount">--</span>
        <span class="player-count-label">players</span>
      </div>
      <div class="player-count">
        <span class="player-count-value" id="gamesPlayed">--</span>
        <span class="player-count-label">games</span>
      </div>
      <div class="wallet-section">
        <span class="wallet-address" id="walletAddress" style="display: none;"></span>
        <button class="wallet-btn" id="walletBtn">CONNECT WALLET</button>
      </div>
    </header>

    <div class="main-content">
      <div class="game-panel">
        <div class="stats-bar">
          <div class="stat-card">
            <div class="stat-label">Current Price</div>
            <div class="stat-value price" id="currentPrice">--</div>
            <div class="price-change" id="priceChange">--</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Score</div>
            <div class="stat-value score" id="score">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Distance</div>
            <div class="stat-value distance" id="distance">0m</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">High Score</div>
            <div class="stat-value score" id="highScore">0</div>
          </div>
        </div>

        <div class="game-container">
          <canvas id="gameCanvas"></canvas>

          <!-- Main Menu -->
          <div class="overlay" id="menuOverlay">
            <h2>PythyBird</h2>
            <p>Navigate through obstacles generated by real-time Pyth Network price feeds. Race against others - last one standing wins!</p>
            <div class="menu-buttons">
              <button class="menu-btn primary" id="soloPlayBtn">PLAY SOLO</button>
              <button class="menu-btn" id="multiplayerBtn">PLAY MULTIPLAYER</button>
              <div class="multiplayer-submenu hidden" id="multiplayerSubmenu">
                <button class="menu-btn sub" id="createLobbyBtn">CREATE RACE</button>
                <button class="menu-btn sub" id="browseLobbyBtn">FIND RACE</button>
                <button class="menu-btn sub" id="joinCodeBtn">JOIN WITH CODE</button>
              </div>
            </div>
            <div id="menuWalletPrompt" style="margin-top: 1rem;">
              <p style="font-size: 0.75rem; color: var(--text-secondary);">Connect wallet to race with others</p>
            </div>
          </div>

          <!-- Lobby Browser -->
          <div class="overlay hidden" id="lobbyBrowserOverlay">
            <h2>FIND A RACE</h2>
            <div class="lobby-list" id="lobbyList">
              <div class="no-lobbies">Loading lobbies...</div>
            </div>
            <div class="modal-buttons">
              <button class="modal-btn secondary" id="browserBackBtn">BACK</button>
              <button class="modal-btn primary" id="browserRefreshBtn">REFRESH</button>
            </div>
          </div>

          <!-- Waiting Room -->
          <div class="overlay hidden" id="waitingRoomOverlay">
            <h2 id="waitingLobbyName">RACE LOBBY</h2>
            <div class="lobby-code-display">
              <div class="label">Share this code</div>
              <div class="code" id="waitingLobbyCode">------</div>
            </div>
            <!-- Wager Info -->
            <div class="wager-info-display hidden" id="wagerInfo" style="margin: 0.5rem 0; padding: 0.5rem 1rem; background: rgba(139, 92, 246, 0.2); border-radius: 4px; color: var(--accent-purple); font-weight: bold;"></div>
            <div class="player-slots" id="playerSlots"></div>
            <p class="waiting-info">Racing on: <span id="waitingFeedSymbol">BTC/USD</span></p>
            <!-- Pot Display -->
            <p class="pot-display hidden" id="potDisplay" style="margin: 0.5rem 0; color: var(--accent-green); font-size: 0.9rem;"></p>
            <p class="ready-status" id="readyStatus">Waiting for players to ready up...</p>
            <div class="modal-buttons">
              <button class="modal-btn secondary" id="leaveLobbyBtn">LEAVE</button>
              <button class="modal-btn deposit hidden" id="depositBtn" style="background: linear-gradient(135deg, #8b5cf6, #6d28d9); border: none;">DEPOSIT</button>
              <button class="modal-btn ready" id="readyBtn">READY</button>
              <button class="modal-btn primary hidden" id="startRaceBtn">START RACE</button>
            </div>
          </div>

          <!-- Race Results -->
          <div class="overlay hidden" id="raceResultsOverlay">
            <h2>RACE FINISHED</h2>
            <div class="results-podium" id="resultsPodium"></div>
            <div class="modal-buttons">
              <button class="modal-btn secondary" id="resultsMenuBtn">MAIN MENU</button>
              <button class="modal-btn primary" id="raceAgainBtn">RACE AGAIN</button>
            </div>
          </div>

          <!-- Solo Start Screen -->
          <div class="overlay hidden" id="startOverlay">
            <h2>SOLO PRACTICE</h2>
            <p>Navigate through obstacles generated by real-time Pyth prices</p>
            <button class="menu-btn primary" id="startBtn">START TRADING</button>
            <button class="menu-btn" id="backToMenuBtn2" style="margin-top: 0.5rem;">BACK TO MENU</button>
          </div>

          <!-- Solo Game Over (existing) -->
          <div class="overlay hidden" id="gameOverOverlay">
            <h2>LIQUIDATED</h2>
            <div class="game-over-stats">
              <div class="game-over-stat">
                <div class="label">Final Score</div>
                <div class="value" id="finalScore">0</div>
              </div>
              <div class="game-over-stat">
                <div class="label">Distance</div>
                <div class="value" id="finalDistance">0m</div>
              </div>
            </div>
            <p>The market got you. Try again?</p>
            <button class="start-btn" id="restartBtn">TRADE AGAIN</button>
            <button class="start-btn" id="soloMenuBtn" style="margin-top: 0.5rem; background: transparent; border: 1px solid rgba(139,92,246,0.3);">MAIN MENU</button>
            <div class="submit-score-section" id="submitScoreSection" style="display: none;">
              <p class="submit-status" id="submitStatus">Submitting score...</p>
            </div>
            <div class="connect-prompt" id="connectPrompt" style="display: none;">
              <p>Connect your Solana wallet to submit score to leaderboard</p>
              <p style="font-size: 0.65rem; color: var(--accent-green); margin-bottom: 0.5rem;">No transactions required. No funds at risk.</p>
              <button class="wallet-btn small" id="gameOverWalletBtn">CONNECT WALLET</button>
            </div>
          </div>

          <!-- Countdown -->
          <div class="countdown-overlay hidden" id="countdownOverlay">
            <div class="countdown-number" id="countdownNumber">3</div>
          </div>

          <!-- Multiplayer Player List (shown during race) -->
          <div class="mp-player-list hidden" id="mpPlayerList"></div>
        </div>

        <!-- Create Lobby Modal -->
        <div class="modal-backdrop hidden" id="createLobbyModal">
          <div class="modal">
            <h3>CREATE RACE</h3>
            <input type="text" id="lobbyNameInput" placeholder="Race Name" maxlength="30">
            <label class="modal-checkbox">
              <input type="checkbox" id="privateToggle">
              Private Lobby (code only)
            </label>
            <p style="font-size: 0.75rem; color: var(--text-secondary);">Racing on: <span id="createFeedSymbol" style="color: var(--accent-green);">BTC/USD</span></p>

            <!-- Wagering Options -->
            <div class="wager-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(139, 92, 246, 0.3);">
              <label class="modal-checkbox" style="margin-bottom: 0.75rem;">
                <input type="checkbox" id="wagerToggle">
                Enable Wagering (Devnet)
              </label>
              <div id="wagerOptions" class="hidden" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="wagerTokenSelect" style="flex: 1; padding: 0.5rem; background: var(--bg-dark); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 4px; color: var(--text-primary); font-family: inherit;">
                    <option value="SOL">SOL</option>
                    <option value="USDC">USDC (Devnet)</option>
                  </select>
                  <input type="number" id="wagerAmountInput" placeholder="Amount" min="0.001" step="0.001" style="width: 100px; padding: 0.5rem; background: var(--bg-dark); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 4px; color: var(--text-primary); font-family: inherit;">
                </div>
                <p style="font-size: 0.7rem; color: var(--accent-purple);">Winner takes all! Each player deposits this amount.</p>
              </div>
            </div>

            <div class="modal-buttons">
              <button class="modal-btn secondary" id="createCancelBtn">CANCEL</button>
              <button class="modal-btn primary" id="createSubmitBtn">CREATE</button>
            </div>
          </div>
        </div>

        <!-- Join Code Modal -->
        <div class="modal-backdrop hidden" id="joinCodeModal">
          <div class="modal">
            <h3>JOIN PRIVATE RACE</h3>
            <input type="text" id="lobbyCodeInput" placeholder="Enter 6-character code" maxlength="6" style="text-transform: uppercase; text-align: center; font-size: 1.5rem; letter-spacing: 0.2em;">
            <div class="modal-buttons">
              <button class="modal-btn secondary" id="joinCancelBtn">CANCEL</button>
              <button class="modal-btn primary" id="joinSubmitBtn">JOIN</button>
            </div>
          </div>
        </div>
      </div>

      <div class="side-panel">
        <div class="panel-card">
          <div class="panel-title">üìä Price Feed</div>
          <div class="price-history" id="priceHistory">
            <div class="loading" style="text-align: center; color: var(--text-secondary);">Waiting for data...</div>
          </div>
        </div>

        <div class="panel-card">
          <div class="panel-title">üéÆ How to Play</div>
          <div class="instructions">
            <p>Press <kbd>SPACE</kbd> or <kbd>CLICK</kbd> to flap and stay airborne.</p>
            <p style="margin-top: 0.5rem;">The <strong>obstacles</strong> are generated from real Pyth price data - price movements create the gaps you navigate through.</p>
            <p style="margin-top: 0.5rem;">Higher <strong>volatility</strong> = harder gameplay!</p>
            <p style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(139, 92, 246, 0.2);">
              <strong style="color: var(--accent-purple);">üîê Leaderboard:</strong> Connect your Solana wallet to save your high scores. <em style="color: var(--accent-green);">No transactions required, no funds at risk.</em>
            </p>
          </div>
        </div>

        <div class="panel-card">
          <div class="panel-title">
            <span>üèÜ High Scores</span>
            <div class="leaderboard-filter">
              <button class="filter-btn active" data-filter="all">All</button>
              <button class="filter-btn" data-filter="feed">This Feed</button>
            </div>
          </div>
          <div class="leaderboard" id="leaderboard">
            <div class="leaderboard-loading">Loading...</div>
          </div>
          <div class="personal-best" id="personalBest" style="display: none;">
            <span class="personal-best-label">Your Best</span>
            <span class="personal-best-score" id="personalBestScore">--</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // PYTH FLAPPY - Price Feed Powered Game
    // ============================================

    // Price Feed Configuration
    const HERMES_ENDPOINT = 'https://hermes.pyth.network';

    // Supabase Configuration - Replace with your project details
    const SUPABASE_URL = 'https://ybayglrpfnqfddihscof.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InliYXlnbHJwZm5xZmRkaWhzY29mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg1MzMxMTgsImV4cCI6MjA4NDEwOTExOH0.TP_aVS7dzVUMiCtSFA3Z30KPdB0244Uk4SyJhDevVu4';

    // Game State
    const state = {
      currentFeed: null,
      currentFeedSymbol: 'BTC/USD',
      currentPrice: null,
      previousPrice: null,
      priceHistory: [],
      eventSource: null,
      connected: false,

      // Feed Discovery
      allFeeds: [],
      filteredFeeds: [],
      searchQuery: '',
      selectedAssetClass: 'all',
      feedsLoading: true,

      // Game
      isPlaying: false,
      score: 0,
      distance: 0,
      highScore: parseInt(localStorage.getItem('pythFlappyHighScore') || '0'),

      // Player
      playerY: 0,
      playerVelocity: 0,

      // Obstacles
      obstacles: [],
      obstacleTimer: 0,

      // Canvas
      canvas: null,
      ctx: null,
      width: 0,
      height: 0,

      // Wallet
      wallet: {
        connected: false,
        publicKey: null,
        displayAddress: null,
        provider: null
      },

      // Leaderboard
      leaderboard: [],
      leaderboardFilter: 'all',

      // Timing (for consistent physics across frame rates)
      lastTime: 0,
      deltaTime: 0,

      // Multiplayer state
      multiplayer: {
        enabled: false,
        isHost: false,
        lobbyId: null,
        lobbyCode: null,
        lobbyName: null,
        hostWallet: null,
        players: [],
        remotePlayers: [],
        gamePhase: 'menu',
        channel: null,
        supabase: null,
        lastPositionSync: 0,
        obstacleIdCounter: 0,
        countdown: 0
      },

      // Local player state (for multiplayer)
      localPlayer: {
        slot: 0,
        alive: true,
        score: 0,
        distance: 0,
        ready: false
      },

      // Wagering state
      wager: {
        enabled: false,
        amount: 0,              // Wager amount in token decimals
        tokenMint: null,        // Token mint address
        tokenSymbol: null,      // e.g., "USDC", "SOL"
        tokenDecimals: 9,       // Token decimals
        racePda: null,          // Race account PDA
        escrowPda: null,        // Escrow token account PDA
        deposited: false,       // Has local player deposited
        allDeposited: false     // Have all players deposited
      },

      // Solana connection
      solana: {
        connection: null,
        programId: null
      }
    };

    // Fixed Virtual Game Resolution (standardized across all players)
    const GAME_WIDTH = 960;
    const GAME_HEIGHT = 540;

    // Game Constants
    const GRAVITY = 0.4;
    const JUMP_FORCE = -8;
    const PLAYER_SIZE = 30;
    const OBSTACLE_WIDTH = 60;
    const OBSTACLE_GAP = 150;
    const OBSTACLE_SPEED = 3;
    const OBSTACLE_INTERVAL = 120; // frames
    const MIN_OBSTACLE_SPACING = 200; // minimum pixels between obstacles

    // Multiplayer Constants
    const PLAYER_COLORS = [
      { main: '#00ff88', glow: 'rgba(0, 255, 136, 0.3)', name: 'Green' },
      { main: '#ff6b6b', glow: 'rgba(255, 107, 107, 0.3)', name: 'Red' },
      { main: '#4ecdc4', glow: 'rgba(78, 205, 196, 0.3)', name: 'Cyan' },
      { main: '#ffe66d', glow: 'rgba(255, 230, 109, 0.3)', name: 'Yellow' }
    ];
    const PLAYER_X_POSITIONS = [0.15, 0.20, 0.25, 0.30];
    const POSITION_SYNC_INTERVAL = 100; // 10Hz
    const INTERPOLATION_BUFFER = 100;

    // Solana Constants (Devnet)
    const SOLANA_NETWORK = 'devnet';
    const SOLANA_RPC_URL = 'https://api.devnet.solana.com';
    // Program ID - Update after deploying to devnet
    const WAGER_PROGRAM_ID = '3P9RXvCHHM55rCaex17M7WB562WvTLSJHeudZpLHqYhN';

    // Available tokens for wagering (Devnet)
    const WAGER_TOKENS = [
      {
        symbol: 'SOL',
        mint: 'So11111111111111111111111111111111111111112',
        decimals: 9,
        name: 'Solana (Wrapped)'
      },
      {
        symbol: 'USDC',
        mint: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
        decimals: 6,
        name: 'USD Coin (Devnet)'
      }
    ];

    // SPL Token Program Constants
    const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
    const SYSTEM_PROGRAM_ID = new solanaWeb3.PublicKey('11111111111111111111111111111111');
    const RENT_SYSVAR_ID = new solanaWeb3.PublicKey('SysvarRent111111111111111111111111111111111');

    // DOM Elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const feedSearchEl = document.getElementById('feedSearch');
    const assetClassBtn = document.getElementById('assetClassBtn');
    const assetClassDropdown = document.getElementById('assetClassDropdown');
    const selectedFeedDisplay = document.getElementById('selectedFeedDisplay');
    const feedResultsEl = document.getElementById('feedResults');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const currentPriceEl = document.getElementById('currentPrice');
    const priceChangeEl = document.getElementById('priceChange');
    const scoreEl = document.getElementById('score');
    const distanceEl = document.getElementById('distance');
    const highScoreEl = document.getElementById('highScore');
    const priceHistoryEl = document.getElementById('priceHistory');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const finalScoreEl = document.getElementById('finalScore');
    const finalDistanceEl = document.getElementById('finalDistance');

    // ============================================
    // PHANTOM WALLET INTEGRATION
    // ============================================

    function getPhantomProvider() {
      if ('phantom' in window) {
        const provider = window.phantom?.solana;
        if (provider?.isPhantom) {
          return provider;
        }
      }
      return null;
    }

    async function connectWallet() {
      const provider = getPhantomProvider();

      if (!provider) {
        window.open('https://phantom.app/', '_blank');
        return false;
      }

      try {
        const response = await provider.connect();
        const publicKey = response.publicKey.toString();

        state.wallet.connected = true;
        state.wallet.publicKey = publicKey;
        state.wallet.displayAddress = truncateAddress(publicKey);
        state.wallet.provider = provider;

        localStorage.setItem('pythFlappyWalletConnected', 'true');
        updateWalletUI();
        fetchPersonalBest();
        return true;
      } catch (error) {
        console.error('Wallet connection failed:', error);
        return false;
      }
    }

    async function disconnectWallet() {
      const provider = getPhantomProvider();

      if (provider && state.wallet.connected) {
        try {
          await provider.disconnect();
        } catch (e) {
          console.log('Disconnect error (ignored):', e);
        }
      }

      state.wallet.connected = false;
      state.wallet.publicKey = null;
      state.wallet.displayAddress = null;
      state.wallet.provider = null;

      localStorage.removeItem('pythFlappyWalletConnected');
      updateWalletUI();
      document.getElementById('personalBest').style.display = 'none';
    }

    function truncateAddress(address) {
      if (!address) return '';
      return `${address.slice(0, 4)}...${address.slice(-4)}`;
    }

    function updateWalletUI() {
      const connectBtn = document.getElementById('walletBtn');
      const walletAddress = document.getElementById('walletAddress');

      if (state.wallet.connected) {
        connectBtn.textContent = 'DISCONNECT';
        connectBtn.classList.add('connected');
        walletAddress.textContent = state.wallet.displayAddress;
        walletAddress.style.display = 'block';
      } else {
        connectBtn.textContent = 'CONNECT WALLET';
        connectBtn.classList.remove('connected');
        walletAddress.style.display = 'none';
      }
    }

    async function initWallet() {
      const provider = getPhantomProvider();

      if (provider) {
        provider.on('accountChanged', (publicKey) => {
          if (publicKey) {
            state.wallet.publicKey = publicKey.toString();
            state.wallet.displayAddress = truncateAddress(state.wallet.publicKey);
            updateWalletUI();
            fetchPersonalBest();
          } else {
            disconnectWallet();
          }
        });

        if (localStorage.getItem('pythFlappyWalletConnected') === 'true') {
          try {
            const response = await provider.connect({ onlyIfTrusted: true });
            state.wallet.connected = true;
            state.wallet.publicKey = response.publicKey.toString();
            state.wallet.displayAddress = truncateAddress(state.wallet.publicKey);
            state.wallet.provider = provider;
            updateWalletUI();
          } catch (e) {
            localStorage.removeItem('pythFlappyWalletConnected');
          }
        }
      }
    }

    function handleWalletClick() {
      if (state.wallet.connected) {
        disconnectWallet();
      } else {
        connectWallet();
      }
    }

    // ============================================
    // SOLANA WAGERING INTEGRATION
    // ============================================

    function initSolanaConnection() {
      try {
        state.solana.connection = new solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
        state.solana.programId = new solanaWeb3.PublicKey(WAGER_PROGRAM_ID);
        console.log('Solana connection initialized:', SOLANA_NETWORK);
      } catch (err) {
        console.error('Failed to initialize Solana connection:', err);
      }
    }

    // Get PDA for race account
    function getRacePda(lobbyCode) {
      const [pda] = solanaWeb3.PublicKey.findProgramAddressSync(
        [Buffer.from('race'), Buffer.from(lobbyCode)],
        state.solana.programId
      );
      return pda;
    }

    // Get PDA for escrow token account
    function getEscrowPda(racePda) {
      const [pda] = solanaWeb3.PublicKey.findProgramAddressSync(
        [Buffer.from('escrow'), racePda.toBuffer()],
        state.solana.programId
      );
      return pda;
    }

    // Get Associated Token Address for a wallet and mint
    function getAssociatedTokenAddress(mint, owner) {
      const [ata] = solanaWeb3.PublicKey.findProgramAddressSync(
        [
          owner.toBuffer(),
          TOKEN_PROGRAM_ID.toBuffer(),
          mint.toBuffer()
        ],
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      return ata;
    }

    // Compute Anchor instruction discriminator (sha256 hash of instruction name)
    async function getInstructionDiscriminator(instructionName) {
      const encoder = new TextEncoder();
      const data = encoder.encode(`global:${instructionName}`);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return new Uint8Array(hashBuffer).slice(0, 8);
    }

    // Format token amount for display
    function formatTokenAmount(amount, decimals) {
      return (amount / Math.pow(10, decimals)).toFixed(decimals > 6 ? 4 : 2);
    }

    // Parse token amount from user input
    function parseTokenAmount(amount, decimals) {
      return Math.floor(parseFloat(amount) * Math.pow(10, decimals));
    }

    // Get user's token balance
    async function getTokenBalance(mint, owner) {
      try {
        const mintPubkey = new solanaWeb3.PublicKey(mint);
        const ownerPubkey = new solanaWeb3.PublicKey(owner);

        // For native SOL
        if (mint === 'So11111111111111111111111111111111111111112') {
          const balance = await state.solana.connection.getBalance(ownerPubkey);
          return balance;
        }

        // For SPL tokens - find associated token account
        const tokenAccounts = await state.solana.connection.getParsedTokenAccountsByOwner(
          ownerPubkey,
          { mint: mintPubkey }
        );

        if (tokenAccounts.value.length > 0) {
          return tokenAccounts.value[0].account.data.parsed.info.tokenAmount.amount;
        }
        return 0;
      } catch (err) {
        console.error('Error getting token balance:', err);
        return 0;
      }
    }

    // Reset wager state
    function resetWagerState() {
      state.wager = {
        enabled: false,
        amount: 0,
        tokenMint: null,
        tokenSymbol: null,
        tokenDecimals: 9,
        racePda: null,
        escrowPda: null,
        deposited: false,
        allDeposited: false
      };
    }

    // Update wager UI in waiting room
    function updateWagerUI() {
      const wagerInfo = document.getElementById('wagerInfo');
      const depositBtn = document.getElementById('depositBtn');
      const potDisplay = document.getElementById('potDisplay');

      if (!state.wager.enabled) {
        if (wagerInfo) wagerInfo.classList.add('hidden');
        if (depositBtn) depositBtn.classList.add('hidden');
        if (potDisplay) potDisplay.classList.add('hidden');
        return;
      }

      if (wagerInfo) {
        wagerInfo.classList.remove('hidden');
        wagerInfo.textContent = `WAGER: ${formatTokenAmount(state.wager.amount, state.wager.tokenDecimals)} ${state.wager.tokenSymbol}`;
      }

      // Count deposited players
      const depositedCount = state.multiplayer.players.filter(p => p.hasDeposited).length;
      const totalPlayers = state.multiplayer.players.length;
      const totalPot = state.wager.amount * depositedCount;

      if (potDisplay) {
        potDisplay.classList.remove('hidden');
        potDisplay.textContent = `POT: ${formatTokenAmount(totalPot, state.wager.tokenDecimals)} ${state.wager.tokenSymbol} (${depositedCount}/${totalPlayers} deposited)`;
      }

      if (depositBtn) {
        if (state.wager.deposited) {
          depositBtn.textContent = 'DEPOSITED';
          depositBtn.disabled = true;
          depositBtn.classList.add('deposited');
        } else {
          depositBtn.textContent = `DEPOSIT ${formatTokenAmount(state.wager.amount, state.wager.tokenDecimals)} ${state.wager.tokenSymbol}`;
          depositBtn.disabled = false;
          depositBtn.classList.remove('deposited');
          depositBtn.classList.remove('hidden');
        }
      }

      // Check if all players deposited
      state.wager.allDeposited = totalPlayers >= 2 && depositedCount === totalPlayers;
      updateStartButton();
    }

    // Deposit wager - transfers tokens to escrow via Solana program
    async function depositWager() {
      if (!state.wallet.connected) {
        alert('Please connect your wallet first');
        return;
      }

      if (state.wager.deposited) {
        alert('You have already deposited');
        return;
      }

      const provider = getPhantomProvider();
      if (!provider) {
        alert('Phantom wallet not found');
        return;
      }

      try {
        // Show loading state
        const depositBtn = document.getElementById('depositBtn');
        if (depositBtn) {
          depositBtn.textContent = 'DEPOSITING...';
          depositBtn.disabled = true;
        }

        console.log('Building deposit transaction...');
        console.log('Lobby code:', state.multiplayer.lobbyCode);
        console.log('Token mint:', state.wager.tokenMint);
        console.log('Amount:', state.wager.amount);

        // Get PDAs
        const racePda = getRacePda(state.multiplayer.lobbyCode);
        const escrowPda = getEscrowPda(racePda);
        const playerPubkey = new solanaWeb3.PublicKey(state.wallet.publicKey);
        const mintPubkey = new solanaWeb3.PublicKey(state.wager.tokenMint);

        // Get player's associated token account
        const playerTokenAccount = getAssociatedTokenAddress(mintPubkey, playerPubkey);

        console.log('Race PDA:', racePda.toString());
        console.log('Escrow PDA:', escrowPda.toString());
        console.log('Player token account:', playerTokenAccount.toString());

        // Get the instruction discriminator for deposit_wager
        const discriminator = await getInstructionDiscriminator('deposit_wager');

        // Build instruction data (just the discriminator, no additional args)
        const instructionData = Buffer.from(discriminator);

        // Build the instruction
        const depositInstruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: racePda, isSigner: false, isWritable: true },
            { pubkey: escrowPda, isSigner: false, isWritable: true },
            { pubkey: playerTokenAccount, isSigner: false, isWritable: true },
            { pubkey: playerPubkey, isSigner: true, isWritable: true },
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
          ],
          programId: state.solana.programId,
          data: instructionData
        });

        // Create transaction
        const transaction = new solanaWeb3.Transaction().add(depositInstruction);

        // Get recent blockhash
        const { blockhash } = await state.solana.connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = playerPubkey;

        console.log('Requesting wallet signature...');

        // Sign and send transaction via Phantom
        const signedTransaction = await provider.signTransaction(transaction);
        const signature = await state.solana.connection.sendRawTransaction(signedTransaction.serialize());

        console.log('Transaction sent:', signature);

        // Wait for confirmation
        const confirmation = await state.solana.connection.confirmTransaction(signature, 'confirmed');

        if (confirmation.value.err) {
          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
        }

        console.log('Deposit confirmed:', signature);

        // Mark as deposited locally
        state.wager.deposited = true;

        // Update database
        await supabaseRequest(`lobby_players?lobby_id=eq.${state.multiplayer.lobbyId}&wallet_address=eq.${state.wallet.publicKey}`, {
          method: 'PATCH',
          body: JSON.stringify({
            has_deposited: true,
            deposit_signature: signature
          })
        });

        // Broadcast deposit to other players
        if (state.multiplayer.channel) {
          state.multiplayer.channel.send({
            type: 'broadcast',
            event: 'game_event',
            payload: {
              type: 'PLAYER_DEPOSIT',
              wallet: state.wallet.publicKey,
              signature: signature
            }
          });
        }

        updateWagerUI();
        renderMpPlayerList();

        alert('Deposit successful! Transaction: ' + signature.slice(0, 20) + '...');

      } catch (err) {
        console.error('Deposit failed:', err);
        alert('Deposit failed: ' + (err.message || err));
        const depositBtn = document.getElementById('depositBtn');
        if (depositBtn) {
          depositBtn.textContent = `DEPOSIT ${formatTokenAmount(state.wager.amount, state.wager.tokenDecimals)} ${state.wager.tokenSymbol}`;
          depositBtn.disabled = false;
        }
      }
    }

    // Handle deposit broadcast from other player
    function handlePlayerDeposit(payload) {
      const player = state.multiplayer.players.find(p => p.wallet === payload.wallet);
      if (player) {
        player.hasDeposited = true;
        renderMpPlayerList();
        updateWagerUI();
      }
    }

    // Declare winner (host only - placeholder for deployed program)
    async function declareWinnerOnChain(winnerWallet) {
      if (!state.multiplayer.isHost) return;
      if (!state.wager.enabled) return;

      try {
        // TODO: Once program is deployed, call declare_winner instruction
        console.log('Would declare winner:', winnerWallet);
        console.log('Total pot:', state.wager.amount * state.multiplayer.players.length);

      } catch (err) {
        console.error('Failed to declare winner on-chain:', err);
      }
    }

    // ============================================
    // SUPABASE API INTEGRATION
    // ============================================

    async function supabaseRequest(endpoint, options = {}) {
      const url = `${SUPABASE_URL}/rest/v1/${endpoint}`;
      const headers = {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
        'Prefer': options.prefer || 'return=minimal'
      };

      const response = await fetch(url, {
        ...options,
        headers: { ...headers, ...options.headers }
      });

      if (!response.ok) {
        throw new Error(`Supabase error: ${response.status}`);
      }

      const text = await response.text();
      return text ? JSON.parse(text) : null;
    }

    async function submitScore(score, distance, priceFeed) {
      if (!state.wallet.connected || !state.wallet.publicKey) {
        console.log('Wallet not connected, score not submitted to leaderboard');
        return false;
      }

      try {
        await supabaseRequest('high_scores', {
          method: 'POST',
          body: JSON.stringify({
            wallet_address: state.wallet.publicKey,
            score: score,
            distance: Math.floor(distance),
            price_feed: priceFeed
          }),
          prefer: 'return=representation'
        });

        console.log('Score submitted successfully');
        await fetchLeaderboard();
        await fetchPlayerCount();
        await fetchGamesPlayed();
        return true;
      } catch (error) {
        console.error('Failed to submit score:', error);
        return false;
      }
    }

    async function fetchLeaderboard(limit = 10, feedFilter = null) {
      try {
        // Fetch more scores to ensure we get enough unique addresses after deduplication
        let query = `high_scores?select=wallet_address,score,distance,price_feed,created_at&order=score.desc&limit=100`;

        if (feedFilter) {
          query += `&price_feed=eq.${encodeURIComponent(feedFilter)}`;
        }

        const scores = await supabaseRequest(query, {
          prefer: 'return=representation'
        });

        // Keep only the highest score per wallet address
        const uniqueScores = [];
        const seenAddresses = new Set();

        for (const score of (scores || [])) {
          if (!seenAddresses.has(score.wallet_address)) {
            seenAddresses.add(score.wallet_address);
            uniqueScores.push(score);
          }
          if (uniqueScores.length >= limit) break;
        }

        state.leaderboard = uniqueScores;
        renderLeaderboard();
        return uniqueScores;
      } catch (error) {
        console.error('Failed to fetch leaderboard:', error);
        state.leaderboard = [];
        renderLeaderboard();
        return [];
      }
    }

    async function fetchPersonalBest() {
      if (!state.wallet.connected || !state.wallet.publicKey) {
        return null;
      }

      try {
        const query = `high_scores?wallet_address=eq.${state.wallet.publicKey}&order=score.desc&limit=1`;
        const results = await supabaseRequest(query, {
          prefer: 'return=representation'
        });

        const personalBestEl = document.getElementById('personalBest');
        const personalBestScoreEl = document.getElementById('personalBestScore');

        if (results && results.length > 0) {
          personalBestEl.style.display = 'flex';
          personalBestScoreEl.textContent = results[0].score;
          return results[0];
        } else {
          personalBestEl.style.display = 'none';
          return null;
        }
      } catch (error) {
        console.error('Failed to fetch personal best:', error);
        return null;
      }
    }

    async function fetchPlayerCount() {
      try {
        const supabase = initSupabaseClient();

        // Get unique wallets from high_scores
        const { data: highScoreWallets } = await supabase
          .from('high_scores')
          .select('wallet_address');

        // Get unique wallets from lobby_players (current multiplayer players)
        const { data: lobbyWallets } = await supabase
          .from('lobby_players')
          .select('wallet_address');

        // Combine and count unique wallets
        const allWallets = new Set();
        if (highScoreWallets) {
          highScoreWallets.forEach(r => allWallets.add(r.wallet_address));
        }
        if (lobbyWallets) {
          lobbyWallets.forEach(r => allWallets.add(r.wallet_address));
        }

        const count = allWallets.size;
        document.getElementById('playerCount').textContent = count.toLocaleString();
        return count;
      } catch (error) {
        console.error('Failed to fetch player count:', error);
        document.getElementById('playerCount').textContent = '--';
        return 0;
      }
    }

    async function fetchGamesPlayed() {
      try {
        const supabase = initSupabaseClient();

        // Count total games from high_scores (each entry = 1 game played)
        const { count, error } = await supabase
          .from('high_scores')
          .select('*', { count: 'exact', head: true });

        if (!error && count !== null) {
          document.getElementById('gamesPlayed').textContent = count.toLocaleString();
          return count;
        }
        return 0;
      } catch (error) {
        console.error('Failed to fetch games played:', error);
        document.getElementById('gamesPlayed').textContent = '--';
        return 0;
      }
    }

    function renderLeaderboard() {
      const leaderboardEl = document.getElementById('leaderboard');

      if (!state.leaderboard || state.leaderboard.length === 0) {
        leaderboardEl.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
        return;
      }

      leaderboardEl.innerHTML = state.leaderboard.map((entry, index) => {
        const isCurrentUser = state.wallet.publicKey === entry.wallet_address;
        const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
        const highlightClass = isCurrentUser ? 'highlight' : '';

        return `
          <div class="leaderboard-entry ${highlightClass}">
            <span class="rank ${rankClass}">${index + 1}</span>
            <span class="address">${truncateAddress(entry.wallet_address)}</span>
            <span class="score">${entry.score}</span>
          </div>
        `;
      }).join('');
    }

    // ============================================
    // MULTIPLAYER LOBBY SYSTEM
    // ============================================

    function initSupabaseClient() {
      if (!state.multiplayer.supabase) {
        state.multiplayer.supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      }
      return state.multiplayer.supabase;
    }

    function generateLobbyCode() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let code = '';
      for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }

    async function createLobby(name, isPrivate, wagerEnabled = false, wagerToken = null, wagerAmount = 0) {
      if (!state.wallet.connected) {
        alert('Please connect your wallet first');
        return null;
      }

      const code = generateLobbyCode();
      const supabase = initSupabaseClient();

      try {
        // Build lobby data
        const lobbyData = {
          code: code,
          name: name || `${state.wallet.displayAddress}'s Race`,
          host_wallet: state.wallet.publicKey,
          price_feed_id: state.currentFeed || '',
          price_feed_symbol: state.currentFeedSymbol,
          is_private: isPrivate,
          status: 'waiting'
        };

        // Add wager fields if enabled
        if (wagerEnabled && wagerToken) {
          lobbyData.wager_enabled = true;
          lobbyData.wager_amount = wagerAmount;
          lobbyData.token_mint = wagerToken.mint;
          lobbyData.token_symbol = wagerToken.symbol;
          lobbyData.token_decimals = wagerToken.decimals;
        }

        // Create lobby
        const { data: lobby, error: lobbyError } = await supabase
          .from('lobbies')
          .insert(lobbyData)
          .select()
          .single();

        if (lobbyError) throw lobbyError;

        // Join as host
        const { error: playerError } = await supabase
          .from('lobby_players')
          .insert({
            lobby_id: lobby.id,
            wallet_address: state.wallet.publicKey,
            player_slot: 0,
            is_host: true,
            has_deposited: false
          });

        if (playerError) throw playerError;

        // Set multiplayer state
        state.multiplayer.enabled = true;
        state.multiplayer.isHost = true;
        state.multiplayer.lobbyId = lobby.id;
        state.multiplayer.lobbyCode = code;
        state.multiplayer.lobbyName = lobby.name;
        state.multiplayer.hostWallet = state.wallet.publicKey;
        state.multiplayer.gamePhase = 'waiting';
        state.localPlayer.slot = 0;

        // Set wager state
        if (wagerEnabled && wagerToken) {
          state.wager.enabled = true;
          state.wager.amount = wagerAmount;
          state.wager.tokenMint = wagerToken.mint;
          state.wager.tokenSymbol = wagerToken.symbol;
          state.wager.tokenDecimals = wagerToken.decimals;
          state.wager.deposited = false;
        } else {
          resetWagerState();
        }

        // Connect to realtime channel
        await connectToLobbyChannel(code);

        return lobby;
      } catch (error) {
        console.error('Failed to create lobby:', error);
        alert('Failed to create lobby. Please try again.');
        return null;
      }
    }

    async function joinLobby(lobbyId, lobbyCode) {
      if (!state.wallet.connected) {
        alert('Please connect your wallet first');
        return false;
      }

      const supabase = initSupabaseClient();

      try {
        // Get lobby info
        const { data: lobby, error: lobbyError } = await supabase
          .from('lobbies')
          .select('*')
          .eq('id', lobbyId)
          .single();

        if (lobbyError) throw lobbyError;
        if (lobby.status !== 'waiting') {
          alert('This race has already started');
          return false;
        }

        // Get current players
        const { data: players, error: playersError } = await supabase
          .from('lobby_players')
          .select('*')
          .eq('lobby_id', lobbyId);

        if (playersError) throw playersError;
        if (players.length >= 4) {
          alert('This lobby is full');
          return false;
        }

        // Check if already in lobby
        if (players.some(p => p.wallet_address === state.wallet.publicKey)) {
          alert('You are already in this lobby');
          return false;
        }

        // Find available slot
        const usedSlots = players.map(p => p.player_slot);
        let availableSlot = 0;
        for (let i = 0; i < 4; i++) {
          if (!usedSlots.includes(i)) {
            availableSlot = i;
            break;
          }
        }

        // Join lobby
        const { error: joinError } = await supabase
          .from('lobby_players')
          .insert({
            lobby_id: lobbyId,
            wallet_address: state.wallet.publicKey,
            player_slot: availableSlot,
            is_host: false,
            has_deposited: false
          });

        if (joinError) throw joinError;

        // Set multiplayer state
        state.multiplayer.enabled = true;
        state.multiplayer.isHost = false;
        state.multiplayer.lobbyId = lobbyId;
        state.multiplayer.lobbyCode = lobbyCode || lobby.code;
        state.multiplayer.lobbyName = lobby.name;
        state.multiplayer.hostWallet = lobby.host_wallet;
        state.multiplayer.gamePhase = 'waiting';
        state.localPlayer.slot = availableSlot;

        // Set wager state from lobby
        if (lobby.wager_enabled) {
          state.wager.enabled = true;
          state.wager.amount = lobby.wager_amount;
          state.wager.tokenMint = lobby.token_mint;
          state.wager.tokenSymbol = lobby.token_symbol;
          state.wager.tokenDecimals = lobby.token_decimals;
          state.wager.deposited = false;
        } else {
          resetWagerState();
        }

        // Connect to realtime channel
        await connectToLobbyChannel(lobby.code);

        return true;
      } catch (error) {
        console.error('Failed to join lobby:', error);
        alert('Failed to join lobby. Please try again.');
        return false;
      }
    }

    async function joinLobbyByCode(code) {
      const supabase = initSupabaseClient();

      try {
        const { data: lobby, error } = await supabase
          .from('lobbies')
          .select('*')
          .eq('code', code.toUpperCase())
          .eq('status', 'waiting')
          .single();

        if (error || !lobby) {
          alert('Lobby not found or already started');
          return false;
        }

        return await joinLobby(lobby.id, code.toUpperCase());
      } catch (error) {
        console.error('Failed to find lobby:', error);
        alert('Lobby not found');
        return false;
      }
    }

    async function leaveLobby() {
      if (!state.multiplayer.lobbyId) return;

      const supabase = initSupabaseClient();
      const lobbyId = state.multiplayer.lobbyId;

      try {
        // Remove player from lobby
        await supabase
          .from('lobby_players')
          .delete()
          .eq('lobby_id', lobbyId)
          .eq('wallet_address', state.wallet.publicKey);

        // Check remaining players
        const { data: remainingPlayers } = await supabase
          .from('lobby_players')
          .select('*')
          .eq('lobby_id', lobbyId);

        if (!remainingPlayers || remainingPlayers.length === 0) {
          // Delete empty lobby
          await supabase
            .from('lobbies')
            .delete()
            .eq('id', lobbyId);
        } else if (state.multiplayer.isHost) {
          // Transfer host to next player
          const newHost = remainingPlayers[0];
          await supabase
            .from('lobbies')
            .update({ host_wallet: newHost.wallet_address })
            .eq('id', lobbyId);

          await supabase
            .from('lobby_players')
            .update({ is_host: true })
            .eq('id', newHost.id);
        }

        // Disconnect from channel
        if (state.multiplayer.channel) {
          await state.multiplayer.channel.unsubscribe();
          state.multiplayer.channel = null;
        }

        // Reset multiplayer state
        resetMultiplayerState();

      } catch (error) {
        console.error('Failed to leave lobby:', error);
      }
    }

    function resetMultiplayerState() {
      state.multiplayer.enabled = false;
      state.multiplayer.isHost = false;
      state.multiplayer.lobbyId = null;
      state.multiplayer.lobbyCode = null;
      state.multiplayer.lobbyName = null;
      state.multiplayer.hostWallet = null;
      state.multiplayer.players = [];
      state.multiplayer.remotePlayers = [];
      state.multiplayer.gamePhase = 'menu';
      state.multiplayer.channel = null;
      state.multiplayer.countdown = 0;
      state.localPlayer.slot = 0;
      state.localPlayer.alive = true;
      state.localPlayer.score = 0;
      state.localPlayer.distance = 0;
      state.localPlayer.ready = false;

      // Reset ready button appearance
      const readyBtn = document.getElementById('readyBtn');
      if (readyBtn) {
        readyBtn.classList.remove('is-ready');
        readyBtn.textContent = 'READY';
      }
    }

    async function cleanupOldLobbies() {
      const supabase = initSupabaseClient();

      try {
        // Get lobbies older than 1 hour
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();

        // Find old lobbies with no players
        const { data: oldLobbies } = await supabase
          .from('lobbies')
          .select(`
            id,
            lobby_players (id)
          `)
          .lt('created_at', oneHourAgo);

        if (oldLobbies && oldLobbies.length > 0) {
          // Filter to only those with no players
          const emptyOldLobbies = oldLobbies
            .filter(lobby => !lobby.lobby_players || lobby.lobby_players.length === 0)
            .map(lobby => lobby.id);

          if (emptyOldLobbies.length > 0) {
            await supabase
              .from('lobbies')
              .delete()
              .in('id', emptyOldLobbies);

            console.log(`Cleaned up ${emptyOldLobbies.length} old empty lobbies`);
          }
        }
      } catch (error) {
        console.error('Failed to cleanup old lobbies:', error);
      }
    }

    async function fetchPublicLobbies() {
      const supabase = initSupabaseClient();

      // Cleanup old empty lobbies first
      await cleanupOldLobbies();

      try {
        const { data: lobbies, error } = await supabase
          .from('lobbies')
          .select(`
            *,
            lobby_players (wallet_address, player_slot)
          `)
          .eq('status', 'waiting')
          .eq('is_private', false)
          .order('created_at', { ascending: false })
          .limit(20);

        if (error) throw error;
        return lobbies || [];
      } catch (error) {
        console.error('Failed to fetch lobbies:', error);
        return [];
      }
    }

    // ============================================
    // SUPABASE REALTIME CHANNEL
    // ============================================

    async function connectToLobbyChannel(lobbyCode) {
      const supabase = initSupabaseClient();

      const channel = supabase.channel(`lobby:${lobbyCode}`, {
        config: {
          broadcast: { self: true },
          presence: { key: state.wallet.publicKey }
        }
      });

      channel
        .on('presence', { event: 'sync' }, () => {
          handlePresenceSync(channel.presenceState());
        })
        .on('presence', { event: 'join' }, ({ key, newPresences }) => {
          console.log('Player joined:', key);
          refreshLobbyPlayers();
        })
        .on('presence', { event: 'leave' }, ({ key }) => {
          console.log('Player left:', key);
          handlePlayerLeave(key);
        })
        .on('broadcast', { event: 'game_event' }, ({ payload }) => {
          handleGameEvent(payload);
        });

      await channel.subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          await channel.track({
            wallet: state.wallet.publicKey,
            slot: state.localPlayer.slot,
            displayName: state.wallet.displayAddress,
            ready: state.localPlayer.ready
          });
          refreshLobbyPlayers();
        }
      });

      state.multiplayer.channel = channel;
    }

    function handlePresenceSync(presenceState) {
      const players = [];
      for (const [wallet, presences] of Object.entries(presenceState)) {
        if (presences.length > 0) {
          players.push({
            wallet: wallet,
            slot: presences[0].slot,
            displayName: presences[0].displayName,
            ready: presences[0].ready || false
          });
        }
      }
      state.multiplayer.players = players;
      renderPlayerSlots();
      updateStartButton();
      updateReadyStatus();
    }

    async function refreshLobbyPlayers() {
      if (!state.multiplayer.lobbyId) return;

      const supabase = initSupabaseClient();
      const { data: players } = await supabase
        .from('lobby_players')
        .select('*')
        .eq('lobby_id', state.multiplayer.lobbyId);

      if (players) {
        state.multiplayer.players = players.map(p => ({
          wallet: p.wallet_address,
          slot: p.player_slot,
          isHost: p.is_host,
          alive: p.is_alive
        }));
        renderPlayerSlots();
        updateStartButton();
      }
    }

    function handlePlayerLeave(wallet) {
      state.multiplayer.players = state.multiplayer.players.filter(p => p.wallet !== wallet);
      state.multiplayer.remotePlayers = state.multiplayer.remotePlayers.filter(p => p.wallet !== wallet);

      if (wallet === state.multiplayer.hostWallet && state.multiplayer.gamePhase === 'waiting') {
        // Host left, refresh to get new host
        refreshLobbyPlayers();
      }

      renderPlayerSlots();
      updateStartButton();

      // Check if game should end
      if (state.multiplayer.gamePhase === 'racing') {
        checkGameEnd();
      }
    }

    function handleGameEvent(payload) {
      switch (payload.type) {
        case 'PLAYER_STATE':
          handleRemotePlayerState(payload);
          break;
        case 'OBSTACLE_SPAWN':
          handleObstacleSpawn(payload);
          break;
        case 'OBSTACLE_SYNC':
          handleObstacleSync(payload);
          break;
        case 'PLAYER_DEATH':
          handlePlayerDeath(payload);
          break;
        case 'GAME_START':
          handleGameStart(payload);
          break;
        case 'GAME_COUNTDOWN':
          handleCountdown(payload);
          break;
        case 'GAME_END':
          handleGameEnd(payload);
          break;
        case 'PLAYER_DEPOSIT':
          handlePlayerDeposit(payload);
          break;
      }
    }

    function handleRemotePlayerState(payload) {
      if (payload.wallet === state.wallet.publicKey) return;

      let player = state.multiplayer.remotePlayers.find(p => p.wallet === payload.wallet);
      if (!player) {
        player = {
          wallet: payload.wallet,
          slot: payload.slot,
          positionBuffer: [],
          alive: true,
          score: 0
        };
        state.multiplayer.remotePlayers.push(player);
      }

      player.alive = payload.alive;
      player.score = payload.score;
      player.positionBuffer.push({
        y: payload.y,
        velocity: payload.velocity,
        timestamp: payload.timestamp
      });

      // Keep buffer size manageable
      if (player.positionBuffer.length > 20) {
        player.positionBuffer.shift();
      }
    }

    function handleObstacleSpawn(payload) {
      if (state.multiplayer.isHost) return; // Host already has the obstacle

      // Check if we already have this obstacle (by ID)
      if (state.obstacles.some(o => o.id === payload.id)) {
        return; // Already have this obstacle
      }

      // Check spacing - don't add if too close to existing obstacle
      const rightmostObstacle = state.obstacles.reduce((max, obs) =>
        obs.x > max ? obs.x : max, 0);
      if (rightmostObstacle > state.width - MIN_OBSTACLE_SPACING) {
        return; // Too close, will get it from sync
      }

      // Convert ratio back to pixels based on local screen height
      // Fallback to center if ratio is invalid
      const gapYRatio = payload.gapYRatio;
      if (typeof gapYRatio !== 'number' || isNaN(gapYRatio)) {
        console.warn('Invalid gapYRatio received:', payload);
        return; // Skip invalid obstacles
      }

      const gapY = gapYRatio * state.height;

      // Validate gapY is within reasonable bounds
      if (gapY < OBSTACLE_GAP / 2 || gapY > state.height - OBSTACLE_GAP / 2) {
        console.warn('gapY out of bounds:', gapY, 'height:', state.height);
      }

      state.obstacles.push({
        id: payload.id,
        x: state.width,
        gapY: Math.max(OBSTACLE_GAP / 2, Math.min(state.height - OBSTACLE_GAP / 2, gapY)),
        passed: false,
        priceAtCreation: payload.price
      });
    }

    function handleObstacleSync(payload) {
      if (state.multiplayer.isHost) return; // Host is the source of truth

      if (!payload.obstacles || !Array.isArray(payload.obstacles)) return;

      // Rebuild obstacles from sync data
      const syncedObstacles = payload.obstacles.map(obs => ({
        id: obs.id,
        x: obs.xRatio * state.width,
        gapY: Math.max(OBSTACLE_GAP / 2, Math.min(state.height - OBSTACLE_GAP / 2, obs.gapYRatio * state.height)),
        passed: obs.passed,
        priceAtCreation: obs.price
      }));

      // Build synced obstacle list - trust host's data completely
      // Host already enforces spacing in generateObstacle()
      const existingById = new Map(state.obstacles.map(o => [o.id, o]));

      const newObstacles = syncedObstacles.map(syncObs => {
        // Use local x position if we already have this obstacle (smoother movement)
        // Otherwise use synced position
        if (existingById.has(syncObs.id)) {
          const local = existingById.get(syncObs.id);
          return {
            ...syncObs,
            x: local.x, // Keep local x for smooth movement
            gapY: syncObs.gapY // Use synced gapY (source of truth)
          };
        }
        return syncObs;
      });

      state.obstacles = newObstacles;
    }

    function handlePlayerDeath(payload) {
      if (payload.wallet === state.wallet.publicKey) return;

      const player = state.multiplayer.remotePlayers.find(p => p.wallet === payload.wallet);
      if (player) {
        player.alive = false;
        player.score = payload.score;
      }

      // Update players list
      const listPlayer = state.multiplayer.players.find(p => p.wallet === payload.wallet);
      if (listPlayer) {
        listPlayer.alive = false;
      }

      showEliminationToast(payload.wallet);
      renderMpPlayerList();
      checkGameEnd();
    }

    function handleGameStart(payload) {
      state.multiplayer.gamePhase = 'countdown';
      startCountdown();
    }

    function handleCountdown(payload) {
      state.multiplayer.countdown = payload.countdown;
      updateCountdownDisplay(payload.countdown);
    }

    function handleGameEnd(payload) {
      state.multiplayer.gamePhase = 'results';
      showRaceResults(payload.rankings);
    }

    // ============================================
    // MULTIPLAYER UI FUNCTIONS
    // ============================================

    function showOverlay(id) {
      document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
      document.getElementById(id)?.classList.remove('hidden');
    }

    function showModal(id) {
      document.getElementById(id)?.classList.remove('hidden');
    }

    function hideModal(id) {
      document.getElementById(id)?.classList.add('hidden');
    }

    function showMainMenu() {
      resetMultiplayerState();
      state.isPlaying = false;
      showOverlay('menuOverlay');
      document.getElementById('mpPlayerList').classList.add('hidden');

      // Reset multiplayer submenu
      const submenu = document.getElementById('multiplayerSubmenu');
      const btn = document.getElementById('multiplayerBtn');
      if (submenu) submenu.classList.add('hidden');
      if (btn) btn.textContent = 'PLAY MULTIPLAYER';
    }

    function showLobbyBrowser() {
      showOverlay('lobbyBrowserOverlay');
      renderLobbyList();
    }

    async function renderLobbyList() {
      const lobbyListEl = document.getElementById('lobbyList');
      lobbyListEl.innerHTML = '<div class="no-lobbies">Loading...</div>';

      const lobbies = await fetchPublicLobbies();

      if (lobbies.length === 0) {
        lobbyListEl.innerHTML = '<div class="no-lobbies">No public races available. Create one!</div>';
        return;
      }

      lobbyListEl.innerHTML = lobbies.map(lobby => {
        const playerCount = lobby.lobby_players?.length || 0;
        return `
          <div class="lobby-item" data-lobby-id="${lobby.id}">
            <div class="lobby-info">
              <span class="lobby-name">${lobby.name}</span>
              <div class="lobby-meta">
                <span class="lobby-feed">${lobby.price_feed_symbol}</span>
                <span class="lobby-players">${playerCount}/4 players</span>
              </div>
            </div>
            <button class="join-btn" onclick="handleJoinLobby('${lobby.id}')">JOIN</button>
          </div>
        `;
      }).join('');
    }

    async function handleJoinLobby(lobbyId) {
      const success = await joinLobby(lobbyId);
      if (success) {
        showWaitingRoom();
      }
    }

    function showWaitingRoom() {
      showOverlay('waitingRoomOverlay');
      document.getElementById('waitingLobbyName').textContent = state.multiplayer.lobbyName;
      document.getElementById('waitingLobbyCode').textContent = state.multiplayer.lobbyCode;
      document.getElementById('waitingFeedSymbol').textContent = state.currentFeedSymbol;
      renderPlayerSlots();
      updateWagerUI();
      updateStartButton();
    }

    function renderPlayerSlots() {
      const slotsEl = document.getElementById('playerSlots');
      if (!slotsEl) return;

      let html = '';
      for (let i = 0; i < 4; i++) {
        const player = state.multiplayer.players.find(p => p.slot === i);
        const color = PLAYER_COLORS[i];
        const isHost = player && player.wallet === state.multiplayer.hostWallet;
        const isReady = player && player.ready;
        const hasDeposited = player && player.hasDeposited;
        const slotClass = player ? (isReady ? 'player-slot occupied ready' : 'player-slot occupied') : 'player-slot';

        if (player) {
          const readyBadge = isReady
            ? '<span class="ready-badge is-ready">READY</span>'
            : '<span class="ready-badge afk">NOT READY</span>';

          // Deposit badge for wager lobbies
          let depositBadge = '';
          if (state.wager.enabled) {
            depositBadge = hasDeposited
              ? '<span class="deposit-badge deposited" style="background: rgba(0,255,136,0.2); color: var(--accent-green); padding: 2px 6px; border-radius: 3px; font-size: 0.65rem; margin-left: 4px;">DEPOSITED</span>'
              : '<span class="deposit-badge pending" style="background: rgba(255,180,0,0.2); color: #ffb400; padding: 2px 6px; border-radius: 3px; font-size: 0.65rem; margin-left: 4px;">PENDING</span>';
          }

          html += `
            <div class="${slotClass}">
              <div class="slot-color" style="background: ${color.main}"></div>
              <div class="slot-info">
                <div class="slot-address">${truncateAddress(player.wallet)}${isHost ? ' <span class="host-badge">HOST</span>' : ''}${depositBadge}</div>
                ${readyBadge}
              </div>
            </div>
          `;
        } else {
          html += `
            <div class="player-slot">
              <div class="slot-color" style="background: ${color.main}; opacity: 0.3"></div>
              <div class="slot-info">
                <div class="slot-waiting">Waiting...</div>
              </div>
            </div>
          `;
        }
      }
      slotsEl.innerHTML = html;
    }

    function updateStartButton() {
      const startBtn = document.getElementById('startRaceBtn');
      if (!startBtn) return;

      const allReady = state.multiplayer.players.length >= 2 &&
        state.multiplayer.players.every(p => p.ready);

      // If wagering is enabled, also require all players to have deposited
      let canStart = allReady;
      if (state.wager.enabled) {
        const allDeposited = state.multiplayer.players.every(p => p.hasDeposited);
        canStart = allReady && allDeposited;
      }

      if (state.multiplayer.isHost && state.multiplayer.players.length >= 2 && canStart) {
        startBtn.classList.remove('hidden');
      } else {
        startBtn.classList.add('hidden');
      }
    }

    function updateReadyStatus() {
      const statusEl = document.getElementById('readyStatus');
      if (!statusEl) return;

      const totalPlayers = state.multiplayer.players.length;
      const readyPlayers = state.multiplayer.players.filter(p => p.ready).length;

      if (totalPlayers < 2) {
        statusEl.textContent = 'Waiting for more players to join...';
        statusEl.classList.remove('all-ready');
      } else if (readyPlayers === totalPlayers) {
        statusEl.textContent = 'All players ready! Host can start the race.';
        statusEl.classList.add('all-ready');
      } else {
        statusEl.textContent = `${readyPlayers}/${totalPlayers} players ready`;
        statusEl.classList.remove('all-ready');
      }
    }

    async function toggleReady() {
      state.localPlayer.ready = !state.localPlayer.ready;

      // Update button appearance
      const readyBtn = document.getElementById('readyBtn');
      if (readyBtn) {
        if (state.localPlayer.ready) {
          readyBtn.classList.add('is-ready');
          readyBtn.textContent = 'READY!';
        } else {
          readyBtn.classList.remove('is-ready');
          readyBtn.textContent = 'READY';
        }
      }

      // Update presence to broadcast ready status
      if (state.multiplayer.channel) {
        await state.multiplayer.channel.track({
          wallet: state.wallet.publicKey,
          slot: state.localPlayer.slot,
          displayName: state.wallet.displayAddress,
          ready: state.localPlayer.ready
        });
      }
    }

    function renderMpPlayerList() {
      const listEl = document.getElementById('mpPlayerList');
      if (!listEl || !state.multiplayer.enabled) return;

      const allPlayers = [
        { wallet: state.wallet.publicKey, slot: state.localPlayer.slot, alive: state.localPlayer.alive, score: state.localPlayer.score },
        ...state.multiplayer.remotePlayers.map(p => ({ wallet: p.wallet, slot: p.slot, alive: p.alive, score: p.score }))
      ].sort((a, b) => a.slot - b.slot);

      listEl.innerHTML = allPlayers.map(p => {
        const color = PLAYER_COLORS[p.slot];
        const eliminated = !p.alive ? 'eliminated' : '';
        return `
          <div class="mp-player-indicator ${eliminated}">
            <div class="color-dot" style="background: ${color.main}"></div>
            <span class="mp-address">${truncateAddress(p.wallet)}</span>
            <span class="mp-score">${p.score}</span>
          </div>
        `;
      }).join('');

      listEl.classList.remove('hidden');
    }

    function showEliminationToast(wallet) {
      const toast = document.createElement('div');
      toast.className = 'elimination-toast';
      toast.textContent = `${truncateAddress(wallet)} ELIMINATED!`;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // ============================================
    // MULTIPLAYER GAME FLOW
    // ============================================

    async function startMultiplayerRace() {
      if (!state.multiplayer.isHost) return;

      // Broadcast game start
      state.multiplayer.channel.send({
        type: 'broadcast',
        event: 'game_event',
        payload: { type: 'GAME_START' }
      });

      startCountdown();
    }

    function startCountdown() {
      state.multiplayer.gamePhase = 'countdown';
      showOverlay('menuOverlay'); // Hide all overlays
      document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
      document.getElementById('countdownOverlay').classList.remove('hidden');

      let count = 3;
      updateCountdownDisplay(count);

      const countdownInterval = setInterval(() => {
        count--;

        if (state.multiplayer.isHost) {
          state.multiplayer.channel.send({
            type: 'broadcast',
            event: 'game_event',
            payload: { type: 'GAME_COUNTDOWN', countdown: count }
          });
        }

        updateCountdownDisplay(count);

        if (count <= 0) {
          clearInterval(countdownInterval);
          setTimeout(() => {
            document.getElementById('countdownOverlay').classList.add('hidden');
            startMultiplayerGame();
          }, 500);
        }
      }, 1000);
    }

    function updateCountdownDisplay(count) {
      const numEl = document.getElementById('countdownNumber');
      if (count <= 0) {
        numEl.textContent = 'GO!';
        numEl.classList.add('go');
      } else {
        numEl.textContent = count;
        numEl.classList.remove('go');
      }
      // Trigger animation
      numEl.style.animation = 'none';
      numEl.offsetHeight; // Reflow
      numEl.style.animation = 'countdownPulse 1s ease-out';
    }

    function startMultiplayerGame() {
      state.multiplayer.gamePhase = 'racing';
      state.isPlaying = true;
      state.score = 0;
      state.distance = 0;
      state.playerY = state.height / 2;
      state.playerVelocity = 0;
      state.obstacles = [];
      state.obstacleTimer = 0;
      state.lastTime = 0;

      state.localPlayer.alive = true;
      state.localPlayer.score = 0;
      state.localPlayer.distance = 0;

      // Reset remote players
      state.multiplayer.remotePlayers.forEach(p => {
        p.alive = true;
        p.score = 0;
        p.positionBuffer = [];
      });

      renderMpPlayerList();
    }

    function broadcastPlayerState() {
      if (!state.multiplayer.enabled || !state.multiplayer.channel) return;
      if (state.multiplayer.gamePhase !== 'racing') return;

      const now = Date.now();
      if (now - state.multiplayer.lastPositionSync < POSITION_SYNC_INTERVAL) return;
      state.multiplayer.lastPositionSync = now;

      state.multiplayer.channel.send({
        type: 'broadcast',
        event: 'game_event',
        payload: {
          type: 'PLAYER_STATE',
          wallet: state.wallet.publicKey,
          slot: state.localPlayer.slot,
          y: state.playerY,
          velocity: state.playerVelocity,
          score: state.localPlayer.score,
          alive: state.localPlayer.alive,
          timestamp: now
        }
      });
    }

    function broadcastObstacleSpawn(obstacle) {
      if (!state.multiplayer.enabled || !state.multiplayer.isHost) return;

      // Normalize gapY to a ratio (0-1) so it works across different screen sizes
      const gapYRatio = obstacle.gapY / state.height;

      state.multiplayer.channel.send({
        type: 'broadcast',
        event: 'game_event',
        payload: {
          type: 'OBSTACLE_SPAWN',
          id: obstacle.id || state.multiplayer.obstacleIdCounter++,
          gapYRatio: gapYRatio,
          price: obstacle.priceAtCreation
        }
      });
    }

    // Periodic full obstacle sync from host (handles missed broadcasts)
    const OBSTACLE_SYNC_INTERVAL = 500; // ms
    let lastObstacleSync = 0;

    function broadcastObstacleSync() {
      if (!state.multiplayer.enabled || !state.multiplayer.isHost) return;
      if (state.multiplayer.gamePhase !== 'racing') return;

      const now = Date.now();
      if (now - lastObstacleSync < OBSTACLE_SYNC_INTERVAL) return;
      lastObstacleSync = now;

      // Send full obstacle list with normalized positions
      const obstacleData = state.obstacles.map(obs => ({
        id: obs.id,
        xRatio: obs.x / state.width,
        gapYRatio: obs.gapY / state.height,
        passed: obs.passed,
        price: obs.priceAtCreation
      }));

      state.multiplayer.channel.send({
        type: 'broadcast',
        event: 'game_event',
        payload: {
          type: 'OBSTACLE_SYNC',
          obstacles: obstacleData
        }
      });
    }

    function broadcastPlayerDeath() {
      if (!state.multiplayer.enabled || !state.multiplayer.channel) return;

      state.multiplayer.channel.send({
        type: 'broadcast',
        event: 'game_event',
        payload: {
          type: 'PLAYER_DEATH',
          wallet: state.wallet.publicKey,
          score: state.localPlayer.score,
          distance: Math.floor(state.localPlayer.distance)
        }
      });
    }

    function checkGameEnd() {
      if (state.multiplayer.gamePhase !== 'racing') return;

      const alivePlayers = [
        state.localPlayer.alive ? state.wallet.publicKey : null,
        ...state.multiplayer.remotePlayers.filter(p => p.alive).map(p => p.wallet)
      ].filter(Boolean);

      if (alivePlayers.length <= 1) {
        // Game ends
        const rankings = calculateRankings();

        if (state.multiplayer.isHost) {
          state.multiplayer.channel.send({
            type: 'broadcast',
            event: 'game_event',
            payload: {
              type: 'GAME_END',
              winner: alivePlayers[0] || rankings[0]?.wallet,
              rankings: rankings
            }
          });
        }

        showRaceResults(rankings);
      }
    }

    function calculateRankings() {
      const allPlayers = [
        { wallet: state.wallet.publicKey, score: state.localPlayer.score, alive: state.localPlayer.alive },
        ...state.multiplayer.remotePlayers.map(p => ({ wallet: p.wallet, score: p.score, alive: p.alive }))
      ];

      // Sort: alive players first, then by score
      return allPlayers.sort((a, b) => {
        if (a.alive && !b.alive) return -1;
        if (!a.alive && b.alive) return 1;
        return b.score - a.score;
      });
    }

    async function showRaceResults(rankings) {
      state.multiplayer.gamePhase = 'results';
      state.isPlaying = false;

      // Submit local player's multiplayer score to track games played
      if (state.wallet.connected) {
        await submitScore(
          state.localPlayer.score,
          state.localPlayer.distance,
          state.currentFeedSymbol + ' (MP)'
        );
      }

      const podiumEl = document.getElementById('resultsPodium');
      let html = '';

      rankings.slice(0, 3).forEach((player, index) => {
        const place = index === 0 ? 'first' : index === 1 ? 'second' : 'third';
        const placeNum = index === 0 ? '1st' : index === 1 ? '2nd' : '3rd';
        const crown = index === 0 ? '<div class="crown">üëë</div>' : '';

        html += `
          <div class="podium-place ${place}">
            ${crown}
            <div class="place-num">${placeNum}</div>
            <div class="place-address">${truncateAddress(player.wallet)}</div>
            <div class="place-score">Score: ${player.score}</div>
          </div>
        `;
      });

      podiumEl.innerHTML = html;
      showOverlay('raceResultsOverlay');
      document.getElementById('mpPlayerList').classList.add('hidden');
    }

    function interpolateRemotePlayer(player, currentTime) {
      const buffer = player.positionBuffer;
      if (!buffer || buffer.length === 0) {
        return { y: state.height / 2, velocity: 0 };
      }

      const renderTime = currentTime - INTERPOLATION_BUFFER;

      // Find two positions to interpolate between
      let before = null, after = null;
      for (let i = 0; i < buffer.length - 1; i++) {
        if (buffer[i].timestamp <= renderTime && buffer[i + 1].timestamp >= renderTime) {
          before = buffer[i];
          after = buffer[i + 1];
          break;
        }
      }

      if (before && after) {
        const t = (renderTime - before.timestamp) / (after.timestamp - before.timestamp);
        return {
          y: before.y + (after.y - before.y) * t,
          velocity: before.velocity + (after.velocity - before.velocity) * t
        };
      }

      // Use latest position
      const latest = buffer[buffer.length - 1];
      return { y: latest.y, velocity: latest.velocity };
    }

    // Initialize
    function init() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Controls
      document.addEventListener('keydown', handleInput);
      canvas.addEventListener('click', handleInput);
      canvas.addEventListener('touchstart', handleInput);

      // Buttons
      startBtn.addEventListener('click', startGame);
      restartBtn.addEventListener('click', startGame);

      // Wallet buttons
      document.getElementById('walletBtn').addEventListener('click', handleWalletClick);
      document.getElementById('gameOverWalletBtn').addEventListener('click', handleWalletClick);

      // Leaderboard filter buttons
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          const filter = e.target.dataset.filter;
          state.leaderboardFilter = filter;
          fetchLeaderboard(10, filter === 'feed' ? state.currentFeedSymbol : null);
        });
      });

      // Feed Discovery Setup
      initFeedDiscovery();

      // Initialize wallet
      initWallet();

      // Initialize Solana connection
      initSolanaConnection();

      // Display high score
      highScoreEl.textContent = state.highScore;

      // Multiplayer button handlers
      document.getElementById('soloPlayBtn')?.addEventListener('click', () => {
        showOverlay('startOverlay');
        document.getElementById('menuOverlay').classList.add('hidden');
      });

      document.getElementById('multiplayerBtn')?.addEventListener('click', () => {
        const submenu = document.getElementById('multiplayerSubmenu');
        const btn = document.getElementById('multiplayerBtn');

        if (submenu.classList.contains('hidden')) {
          if (!state.wallet.connected) {
            alert('Please connect your wallet first to play multiplayer');
            return;
          }
          submenu.classList.remove('hidden');
          btn.textContent = 'BACK';
        } else {
          submenu.classList.add('hidden');
          btn.textContent = 'PLAY MULTIPLAYER';
        }
      });

      document.getElementById('createLobbyBtn')?.addEventListener('click', () => {
        if (!state.wallet.connected) {
          alert('Please connect your wallet first to create a lobby');
          return;
        }
        showModal('createLobbyModal');
      });

      document.getElementById('browseLobbyBtn')?.addEventListener('click', () => {
        if (!state.wallet.connected) {
          alert('Please connect your wallet first to join a race');
          return;
        }
        showLobbyBrowser();
      });

      document.getElementById('joinCodeBtn')?.addEventListener('click', () => {
        if (!state.wallet.connected) {
          alert('Please connect your wallet first to join a race');
          return;
        }
        showModal('joinCodeModal');
      });

      document.getElementById('createSubmitBtn')?.addEventListener('click', async () => {
        const nameInput = document.getElementById('lobbyNameInput');
        const privateCheckbox = document.getElementById('privateToggle');
        const wagerToggle = document.getElementById('wagerToggle');
        const wagerTokenSelect = document.getElementById('wagerTokenSelect');
        const wagerAmountInput = document.getElementById('wagerAmountInput');

        const name = nameInput.value.trim() || 'Unnamed Race';
        const isPrivate = privateCheckbox.checked;

        // Wager options
        let wagerEnabled = wagerToggle?.checked || false;
        let wagerToken = null;
        let wagerAmount = 0;

        if (wagerEnabled) {
          const tokenSymbol = wagerTokenSelect?.value || 'SOL';
          wagerToken = WAGER_TOKENS.find(t => t.symbol === tokenSymbol);
          const rawAmount = parseFloat(wagerAmountInput?.value || 0);

          if (!wagerToken || rawAmount <= 0) {
            alert('Please enter a valid wager amount');
            return;
          }

          wagerAmount = parseTokenAmount(rawAmount, wagerToken.decimals);
        }

        hideModal('createLobbyModal');
        const success = await createLobby(name, isPrivate, wagerEnabled, wagerToken, wagerAmount);
        if (success) {
          showWaitingRoom();
        }

        // Reset form
        nameInput.value = '';
        privateCheckbox.checked = false;
        if (wagerToggle) wagerToggle.checked = false;
        if (wagerAmountInput) wagerAmountInput.value = '';
        document.getElementById('wagerOptions')?.classList.add('hidden');
      });

      document.getElementById('createCancelBtn')?.addEventListener('click', () => {
        hideModal('createLobbyModal');
        // Reset wager toggle
        const wagerToggle = document.getElementById('wagerToggle');
        if (wagerToggle) wagerToggle.checked = false;
        document.getElementById('wagerOptions')?.classList.add('hidden');
      });

      // Wager toggle handler
      document.getElementById('wagerToggle')?.addEventListener('change', (e) => {
        const wagerOptions = document.getElementById('wagerOptions');
        if (e.target.checked) {
          wagerOptions?.classList.remove('hidden');
        } else {
          wagerOptions?.classList.add('hidden');
        }
      });

      document.getElementById('joinSubmitBtn')?.addEventListener('click', async () => {
        const codeInput = document.getElementById('lobbyCodeInput');
        const code = codeInput.value.trim().toUpperCase();

        if (code.length !== 6) {
          alert('Please enter a valid 6-character lobby code');
          return;
        }

        hideModal('joinCodeModal');
        const success = await joinLobbyByCode(code);
        if (success) {
          showWaitingRoom();
        }
        codeInput.value = '';
      });

      document.getElementById('joinCancelBtn')?.addEventListener('click', () => {
        hideModal('joinCodeModal');
      });

      document.getElementById('startRaceBtn')?.addEventListener('click', () => {
        startMultiplayerRace();
      });

      document.getElementById('readyBtn')?.addEventListener('click', () => {
        toggleReady();
      });

      document.getElementById('leaveLobbyBtn')?.addEventListener('click', async () => {
        await leaveLobby();
        showMainMenu();
      });

      // Deposit button for wagering
      document.getElementById('depositBtn')?.addEventListener('click', async () => {
        await depositWager();
      });

      document.getElementById('browserBackBtn')?.addEventListener('click', () => {
        showMainMenu();
      });

      document.getElementById('browserRefreshBtn')?.addEventListener('click', () => {
        renderLobbyList();
      });

      document.getElementById('raceAgainBtn')?.addEventListener('click', async () => {
        // Reset for another race
        state.multiplayer.gamePhase = 'waiting';
        state.localPlayer.alive = true;
        state.localPlayer.score = 0;
        state.localPlayer.ready = false;
        state.multiplayer.remotePlayers.forEach(p => {
          p.alive = true;
          p.score = 0;
          p.positionBuffer = [];
        });

        // Reset ready button appearance
        const readyBtn = document.getElementById('readyBtn');
        if (readyBtn) {
          readyBtn.classList.remove('is-ready');
          readyBtn.textContent = 'READY';
        }

        // Update presence with reset ready status
        if (state.multiplayer.channel) {
          await state.multiplayer.channel.track({
            wallet: state.wallet.publicKey,
            slot: state.localPlayer.slot,
            displayName: state.wallet.displayAddress,
            ready: false
          });
        }

        showWaitingRoom();
      });

      document.getElementById('resultsMenuBtn')?.addEventListener('click', async () => {
        await leaveLobby();
        showMainMenu();
      });

      document.getElementById('backToMenuBtn2')?.addEventListener('click', () => {
        showMainMenu();
      });

      document.getElementById('soloMenuBtn')?.addEventListener('click', () => {
        showMainMenu();
      });

      // Fetch all feeds and connect to default
      fetchAllFeeds();

      // Fetch initial leaderboard and player count
      fetchLeaderboard();
      fetchPlayerCount();
      fetchGamesPlayed();

      // Start render loop
      requestAnimationFrame(gameLoop);
    }

    // ============================================
    // FEED DISCOVERY SYSTEM
    // ============================================

    async function fetchAllFeeds() {
      state.feedsLoading = true;
      renderFeedResults();

      try {
        const response = await fetch(`${HERMES_ENDPOINT}/v2/price_feeds`);
        const feeds = await response.json();

        // Sort alphabetically by symbol and store
        state.allFeeds = feeds.sort((a, b) => {
          const symbolA = a.attributes?.symbol || a.id;
          const symbolB = b.attributes?.symbol || b.id;
          return symbolA.localeCompare(symbolB);
        });

        state.feedsLoading = false;
        filterFeeds();

        // Connect to default BTC/USD feed
        const btcFeed = state.allFeeds.find(f =>
          f.attributes?.symbol === 'Crypto.BTC/USD' ||
          f.attributes?.base === 'BTC'
        );
        if (btcFeed) {
          selectFeed(btcFeed.id, btcFeed.attributes?.symbol || 'BTC/USD');
        } else if (state.allFeeds.length > 0) {
          const firstFeed = state.allFeeds[0];
          selectFeed(firstFeed.id, firstFeed.attributes?.symbol || firstFeed.id.slice(0, 10));
        }
      } catch (error) {
        console.error('Failed to fetch price feeds:', error);
        state.feedsLoading = false;
        // Fallback to hardcoded BTC feed
        connectToFeed('0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43');
      }
    }

    function initFeedDiscovery() {
      // Search input
      feedSearchEl.addEventListener('input', (e) => {
        state.searchQuery = e.target.value.toLowerCase();
        filterFeeds();
      });

      feedSearchEl.addEventListener('focus', () => {
        feedResultsEl.classList.add('open');
      });

      // Asset class dropdown toggle
      assetClassBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        assetClassDropdown.classList.toggle('open');
        feedResultsEl.classList.remove('open');
      });

      // Asset class selection
      assetClassDropdown.querySelectorAll('.asset-class-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          const assetClass = option.dataset.class;
          state.selectedAssetClass = assetClass;

          // Update selected state
          assetClassDropdown.querySelectorAll('.asset-class-option').forEach(opt => {
            opt.classList.remove('selected');
          });
          option.classList.add('selected');

          // Update button text
          assetClassBtn.textContent = option.textContent;

          // Close dropdown and filter
          assetClassDropdown.classList.remove('open');
          filterFeeds();
        });
      });

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.feed-discovery')) {
          assetClassDropdown.classList.remove('open');
          feedResultsEl.classList.remove('open');
        }
      });
    }

    function filterFeeds() {
      const query = state.searchQuery;
      const assetClass = state.selectedAssetClass;

      state.filteredFeeds = state.allFeeds.filter(feed => {
        const symbol = (feed.attributes?.symbol || '').toLowerCase();
        const base = (feed.attributes?.base || '').toLowerCase();
        const feedAssetClass = (feed.attributes?.asset_type || '').toLowerCase();

        // Search filter
        const matchesSearch = !query ||
          symbol.includes(query) ||
          base.includes(query);

        // Asset class filter
        const matchesClass = assetClass === 'all' ||
          feedAssetClass === assetClass;

        return matchesSearch && matchesClass;
      });

      renderFeedResults();
    }

    function renderFeedResults() {
      if (state.feedsLoading) {
        feedResultsEl.innerHTML = '<div class="feed-loading">Loading feeds...</div>';
        return;
      }

      if (state.filteredFeeds.length === 0) {
        feedResultsEl.innerHTML = '<div class="feed-no-results">No feeds found</div>';
        return;
      }

      // Limit to first 50 results for performance
      const displayFeeds = state.filteredFeeds.slice(0, 50);

      feedResultsEl.innerHTML = displayFeeds.map(feed => {
        const symbol = feed.attributes?.symbol || feed.id.slice(0, 10);
        const assetType = feed.attributes?.asset_type || 'unknown';
        const displaySymbol = symbol.replace('Crypto.', '').replace('Equity.', '').replace('FX.', '');

        return `<div class="feed-result-item" data-feed-id="${feed.id}" data-symbol="${displaySymbol}">
          <span class="feed-result-symbol">${displaySymbol}</span>
          <span class="feed-result-class">${assetType}</span>
        </div>`;
      }).join('');

      // Add click handlers
      feedResultsEl.querySelectorAll('.feed-result-item').forEach(item => {
        item.addEventListener('click', () => {
          const feedId = item.dataset.feedId;
          const symbol = item.dataset.symbol;
          selectFeed(feedId, symbol);
          feedResultsEl.classList.remove('open');
          feedSearchEl.value = '';
          state.searchQuery = '';
        });
      });
    }

    function selectFeed(feedId, symbol) {
      state.currentFeed = feedId;
      state.currentFeedSymbol = symbol;
      selectedFeedDisplay.textContent = symbol;
      connectToFeed(feedId);

      // Reset obstacles when changing feed
      if (state.isPlaying) {
        state.obstacles = [];
      }
    }

    function resizeCanvas() {
      // Use fixed virtual resolution for consistent gameplay across all screen sizes
      canvas.width = GAME_WIDTH;
      canvas.height = GAME_HEIGHT;
      state.width = GAME_WIDTH;
      state.height = GAME_HEIGHT;

      // Scale canvas to fit container while maintaining aspect ratio
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      const containerRatio = containerWidth / containerHeight;
      const gameRatio = GAME_WIDTH / GAME_HEIGHT;

      let displayWidth, displayHeight;
      if (containerRatio > gameRatio) {
        // Container is wider - fit to height
        displayHeight = containerHeight;
        displayWidth = containerHeight * gameRatio;
      } else {
        // Container is taller - fit to width
        displayWidth = containerWidth;
        displayHeight = containerWidth / gameRatio;
      }

      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';

      // Only reset player position if not currently playing
      if (!state.isPlaying) {
        state.playerY = state.height / 2;
      }
    }

    // ============================================
    // PYTH PRICE FEED CONNECTION
    // ============================================

    function connectToFeed(feedId) {
      // Close existing connection
      if (state.eventSource) {
        state.eventSource.close();
      }

      state.connected = false;
      updateConnectionStatus(false, 'Connecting...');
      state.priceHistory = [];
      updatePriceHistoryDisplay();

      // Use Server-Sent Events for streaming
      const streamUrl = `${HERMES_ENDPOINT}/v2/updates/price/stream?ids[]=${feedId}&parsed=true`;
      
      state.eventSource = new EventSource(streamUrl);

      state.eventSource.onopen = () => {
        state.connected = true;
        updateConnectionStatus(true, 'Live');
      };

      state.eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.parsed && data.parsed.length > 0) {
            const priceData = data.parsed[0];
            processPriceUpdate(priceData);
          }
        } catch (e) {
          console.error('Error parsing price data:', e);
        }
      };

      state.eventSource.onerror = (error) => {
        console.error('SSE Error:', error);
        state.connected = false;
        updateConnectionStatus(false, 'Reconnecting...');
        
        // Reconnect after delay
        setTimeout(() => {
          if (!state.connected && state.currentFeed) {
            connectToFeed(state.currentFeed);
          }
        }, 3000);
      };
    }

    function processPriceUpdate(priceData) {
      const price = parseFloat(priceData.price.price) * Math.pow(10, priceData.price.expo);
      const confidence = parseFloat(priceData.price.conf) * Math.pow(10, priceData.price.expo);
      
      state.previousPrice = state.currentPrice;
      state.currentPrice = price;
      
      // Add to history
      const entry = {
        price: price,
        confidence: confidence,
        timestamp: new Date(),
        change: state.previousPrice ? price - state.previousPrice : 0
      };
      
      state.priceHistory.unshift(entry);
      if (state.priceHistory.length > 50) {
        state.priceHistory.pop();
      }

      // Update UI
      updatePriceDisplay(price, entry.change);
      updatePriceHistoryDisplay();
      
      // Generate obstacle from price if playing
      if (state.isPlaying && state.priceHistory.length >= 2) {
        // Use price change to influence obstacle gap position
        const priceChange = entry.change;
        const normalizedChange = Math.max(-1, Math.min(1, priceChange / (price * 0.001)));
        
        // Queue this for obstacle generation
        state.lastPriceNormalized = normalizedChange;
      }
    }

    function updateConnectionStatus(connected, text) {
      statusDot.classList.toggle('connected', connected);
      statusText.textContent = text;
    }

    function updatePriceDisplay(price, change) {
      // Format price based on magnitude
      let formatted;
      if (price >= 1000) {
        formatted = price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } else if (price >= 1) {
        formatted = price.toFixed(4);
      } else {
        formatted = price.toFixed(6);
      }
      
      currentPriceEl.textContent = '$' + formatted;
      
      // Price change
      if (change !== 0) {
        const changePercent = ((change / (price - change)) * 100).toFixed(3);
        const isUp = change > 0;
        priceChangeEl.textContent = `${isUp ? '‚ñ≤' : '‚ñº'} ${isUp ? '+' : ''}${changePercent}%`;
        priceChangeEl.className = `price-change ${isUp ? 'up' : 'down'}`;
      }
    }

    function updatePriceHistoryDisplay() {
      if (state.priceHistory.length === 0) {
        priceHistoryEl.innerHTML = '<div class="loading" style="text-align: center; color: var(--text-secondary);">Waiting for data...</div>';
        return;
      }

      priceHistoryEl.innerHTML = state.priceHistory.slice(0, 20).map(entry => {
        const time = entry.timestamp.toLocaleTimeString();
        const price = entry.price >= 1 ? entry.price.toFixed(2) : entry.price.toFixed(6);
        const direction = entry.change >= 0 ? 'up' : 'down';
        return `<div class="price-entry ${direction}">
          <span class="time">${time}</span>
          <span class="price">$${price}</span>
        </div>`;
      }).join('');
    }

    // ============================================
    // GAME LOGIC
    // ============================================

    function startGame() {
      state.isPlaying = true;
      state.score = 0;
      state.distance = 0;
      state.playerY = state.height / 2;
      state.playerVelocity = 0;
      state.obstacles = [];
      state.obstacleTimer = 0;
      state.lastTime = 0; // Reset timing to prevent big delta on first frame

      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');

      updateScore();
    }

    async function gameOver() {
      state.isPlaying = false;

      // Update local high score
      if (state.score > state.highScore) {
        state.highScore = state.score;
        localStorage.setItem('pythFlappyHighScore', state.highScore.toString());
        highScoreEl.textContent = state.highScore;
      }

      finalScoreEl.textContent = state.score;
      finalDistanceEl.textContent = Math.floor(state.distance) + 'm';

      // Handle score submission UI
      const submitSection = document.getElementById('submitScoreSection');
      const connectPrompt = document.getElementById('connectPrompt');
      const submitStatus = document.getElementById('submitStatus');

      if (state.wallet.connected) {
        // Show submission status
        submitSection.style.display = 'block';
        connectPrompt.style.display = 'none';
        submitStatus.textContent = 'Submitting score...';
        submitStatus.className = 'submit-status';

        // Submit score to Supabase
        const success = await submitScore(
          state.score,
          state.distance,
          state.currentFeedSymbol
        );

        if (success) {
          submitStatus.textContent = 'Score submitted to leaderboard!';
          submitStatus.className = 'submit-status success';
          fetchPersonalBest();
        } else {
          submitStatus.textContent = 'Failed to submit score';
          submitStatus.className = 'submit-status error';
        }
      } else {
        // Show connect wallet prompt
        submitSection.style.display = 'none';
        connectPrompt.style.display = 'block';
      }

      gameOverOverlay.classList.remove('hidden');
    }

    function handleInput(e) {
      if (e.type === 'keydown' && e.code !== 'Space') return;
      if (e.type === 'keydown') e.preventDefault();

      if (state.isPlaying) {
        state.playerVelocity = JUMP_FORCE;
      } else if (!gameOverOverlay.classList.contains('hidden')) {
        // Restart game from game over screen
        startGame();
      }
    }

    function updateScore() {
      scoreEl.textContent = state.score;
      distanceEl.textContent = Math.floor(state.distance) + 'm';
    }

    // ============================================
    // GAME LOOP
    // ============================================

    const TARGET_FPS = 60;
    const TARGET_FRAME_TIME = 1000 / TARGET_FPS;

    function gameLoop(currentTime) {
      // Calculate delta time and normalize to 60fps
      if (state.lastTime === 0) {
        state.lastTime = currentTime;
      }
      const rawDelta = currentTime - state.lastTime;
      state.lastTime = currentTime;

      // Normalize delta time (1.0 = 60fps, 0.5 = 120fps, 2.0 = 30fps)
      // Cap delta to prevent huge jumps if tab was inactive
      state.deltaTime = Math.min(rawDelta / TARGET_FRAME_TIME, 3);

      update();
      render();
      requestAnimationFrame(gameLoop);
    }

    function update() {
      if (!state.isPlaying) return;

      // In multiplayer, only update if local player is alive
      if (state.multiplayer.enabled && !state.localPlayer.alive) {
        // Still broadcast state and render, but don't process physics
        return;
      }

      const dt = state.deltaTime;

      // Physics (scaled by delta time)
      state.playerVelocity += GRAVITY * dt;
      state.playerY += state.playerVelocity * dt;
      state.distance += OBSTACLE_SPEED * 0.1 * dt;

      // Update local player distance in multiplayer
      if (state.multiplayer.enabled) {
        state.localPlayer.distance = state.distance;
      }

      // Bounds check
      if (state.playerY < PLAYER_SIZE / 2 || state.playerY > state.height - PLAYER_SIZE / 2) {
        handlePlayerCollision();
        return;
      }

      // Generate obstacles (only host in multiplayer, or solo mode)
      if (!state.multiplayer.enabled || state.multiplayer.isHost) {
        state.obstacleTimer += dt;
        if (state.obstacleTimer >= OBSTACLE_INTERVAL) {
          state.obstacleTimer = 0;
          generateObstacle();
        }
      }

      // Update obstacles
      for (let i = state.obstacles.length - 1; i >= 0; i--) {
        const obs = state.obstacles[i];
        obs.x -= OBSTACLE_SPEED * dt;

        // Score when passing - use player's X position based on slot in multiplayer
        const playerX = state.multiplayer.enabled ?
          state.width * PLAYER_X_POSITIONS[state.localPlayer.slot] :
          state.width / 4;

        if (!obs.passed && obs.x + OBSTACLE_WIDTH < playerX) {
          obs.passed = true;
          state.score++;
          if (state.multiplayer.enabled) {
            state.localPlayer.score = state.score;
          }
          updateScore();
        }

        // Remove off-screen
        if (obs.x + OBSTACLE_WIDTH < 0) {
          state.obstacles.splice(i, 1);
          continue;
        }

        // Collision detection - use player's X position based on slot in multiplayer
        const playerLeft = playerX - PLAYER_SIZE / 2;
        const playerRight = playerX + PLAYER_SIZE / 2;
        const playerTop = state.playerY - PLAYER_SIZE / 2;
        const playerBottom = state.playerY + PLAYER_SIZE / 2;

        if (playerRight > obs.x && playerLeft < obs.x + OBSTACLE_WIDTH) {
          if (playerTop < obs.gapY - OBSTACLE_GAP / 2 || playerBottom > obs.gapY + OBSTACLE_GAP / 2) {
            handlePlayerCollision();
            return;
          }
        }
      }

      // Broadcast player state in multiplayer
      if (state.multiplayer.enabled) {
        broadcastPlayerState();
        // Host periodically syncs full obstacle list for reliability
        if (state.multiplayer.isHost) {
          broadcastObstacleSync();
        }
        renderMpPlayerList();
      }
    }

    function handlePlayerCollision() {
      if (state.multiplayer.enabled) {
        // Multiplayer: Player elimination
        state.localPlayer.alive = false;
        state.localPlayer.score = state.score;
        broadcastPlayerDeath();
        showEliminationToast(state.wallet.publicKey);
        renderMpPlayerList();
        checkGameEnd();
      } else {
        // Solo mode: Game over
        gameOver();
      }
    }

    function generateObstacle() {
      // Check if there's already an obstacle too close to the spawn position
      const rightmostObstacle = state.obstacles.reduce((max, obs) =>
        obs.x > max ? obs.x : max, 0);

      if (rightmostObstacle > state.width - MIN_OBSTACLE_SPACING) {
        // Too close to existing obstacle, skip this generation
        return;
      }

      // Use price data to determine gap position - same calculation as green price line
      let gapY = state.height / 2;

      if (state.priceHistory.length >= 2) {
        // Use same normalization as drawPriceLine for consistency
        const prices = state.priceHistory.slice(0, 30);
        const minPrice = Math.min(...prices.map(p => p.price));
        const maxPrice = Math.max(...prices.map(p => p.price));
        const priceRange = maxPrice - minPrice || 1;

        // Normalize current price between min/max (same as green line)
        const normalized = (state.currentPrice - minPrice) / priceRange;

        // Map to screen position using same formula as drawPriceLine
        gapY = state.height - (normalized * state.height * 0.6 + state.height * 0.2);
      } else {
        // Random if no price data
        gapY = OBSTACLE_GAP / 2 + 50 + Math.random() * (state.height - OBSTACLE_GAP - 100);
      }

      // Clamp gap position
      gapY = Math.max(OBSTACLE_GAP / 2 + 30, Math.min(state.height - OBSTACLE_GAP / 2 - 30, gapY));

      const obstacle = {
        id: state.multiplayer.obstacleIdCounter++,
        x: state.width,
        gapY: gapY,
        passed: false,
        priceAtCreation: state.currentPrice
      };

      state.obstacles.push(obstacle);

      // Broadcast obstacle to other players in multiplayer
      if (state.multiplayer.enabled && state.multiplayer.isHost) {
        broadcastObstacleSpawn(obstacle);
      }
    }

    // ============================================
    // RENDERING
    // ============================================

    function render() {
      // Clear
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, state.width, state.height);

      // Grid background
      drawGrid();

      // Price line visualization (background)
      drawPriceLine();

      // Obstacles
      drawObstacles();

      // Players
      if (state.multiplayer.enabled && state.multiplayer.gamePhase === 'racing') {
        drawAllPlayers();
      } else {
        drawPlayer();
      }

      // Idle state visualization
      if (!state.isPlaying) {
        drawIdleVisualization();
      }
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(139, 92, 246, 0.1)';
      ctx.lineWidth = 1;

      // Vertical lines
      for (let x = 0; x < state.width; x += 60) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, state.height);
        ctx.stroke();
      }

      // Horizontal lines
      for (let y = 0; y < state.height; y += 60) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(state.width, y);
        ctx.stroke();
      }
    }

    function drawPriceLine() {
      if (state.priceHistory.length < 2) return;

      const prices = state.priceHistory.slice(0, 30);
      const minPrice = Math.min(...prices.map(p => p.price));
      const maxPrice = Math.max(...prices.map(p => p.price));
      const priceRange = maxPrice - minPrice || 1;

      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
      ctx.lineWidth = 2;

      prices.forEach((entry, i) => {
        const x = state.width - (i * (state.width / 30));
        const normalized = (entry.price - minPrice) / priceRange;
        const y = state.height - (normalized * state.height * 0.6 + state.height * 0.2);

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();

      // Glow effect
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
      ctx.lineWidth = 6;
      ctx.stroke();
    }

    function drawObstacles() {
      state.obstacles.forEach(obs => {
        // Top obstacle
        const gradient1 = ctx.createLinearGradient(obs.x, 0, obs.x + OBSTACLE_WIDTH, 0);
        gradient1.addColorStop(0, '#8b5cf6');
        gradient1.addColorStop(1, '#6d28d9');
        
        ctx.fillStyle = gradient1;
        ctx.fillRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY - OBSTACLE_GAP / 2);
        
        // Bottom obstacle
        ctx.fillStyle = gradient1;
        ctx.fillRect(obs.x, obs.gapY + OBSTACLE_GAP / 2, OBSTACLE_WIDTH, state.height - obs.gapY - OBSTACLE_GAP / 2);

        // Glow edges
        ctx.strokeStyle = 'rgba(139, 92, 246, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY - OBSTACLE_GAP / 2);
        ctx.strokeRect(obs.x, obs.gapY + OBSTACLE_GAP / 2, OBSTACLE_WIDTH, state.height - obs.gapY - OBSTACLE_GAP / 2);

        // Price label
        if (obs.priceAtCreation) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.font = '10px "Space Mono"';
          ctx.textAlign = 'center';
          const priceLabel = obs.priceAtCreation >= 1 ? 
            '$' + obs.priceAtCreation.toFixed(0) : 
            '$' + obs.priceAtCreation.toFixed(4);
          ctx.fillText(priceLabel, obs.x + OBSTACLE_WIDTH / 2, obs.gapY);
        }
      });
    }

    function drawPlayer() {
      const x = state.width / 4;
      const y = state.isPlaying ? state.playerY : state.height / 2 + Math.sin(Date.now() / 500) * 10;

      // Glow
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 20;

      // Player body (rocket/ship shape)
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.moveTo(x + PLAYER_SIZE / 2, y);
      ctx.lineTo(x - PLAYER_SIZE / 2, y - PLAYER_SIZE / 3);
      ctx.lineTo(x - PLAYER_SIZE / 3, y);
      ctx.lineTo(x - PLAYER_SIZE / 2, y + PLAYER_SIZE / 3);
      ctx.closePath();
      ctx.fill();

      // Trail effect when moving
      if (state.isPlaying && state.playerVelocity < 0) {
        ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
        ctx.beginPath();
        ctx.moveTo(x - PLAYER_SIZE / 2, y);
        ctx.lineTo(x - PLAYER_SIZE, y - 5);
        ctx.lineTo(x - PLAYER_SIZE * 1.5, y);
        ctx.lineTo(x - PLAYER_SIZE, y + 5);
        ctx.closePath();
        ctx.fill();
      }

      ctx.shadowBlur = 0;
    }

    function drawAllPlayers() {
      const currentTime = Date.now();

      // Draw remote players first (behind local player)
      state.multiplayer.remotePlayers.forEach(player => {
        if (!player.alive) return;

        const interpolated = interpolateRemotePlayer(player, currentTime);
        const color = PLAYER_COLORS[player.slot];
        const x = state.width * PLAYER_X_POSITIONS[player.slot];
        const y = interpolated.y;

        drawPlayerShip(x, y, color, player.wallet, interpolated.velocity);
      });

      // Draw local player on top
      if (state.localPlayer.alive) {
        const color = PLAYER_COLORS[state.localPlayer.slot];
        const x = state.width * PLAYER_X_POSITIONS[state.localPlayer.slot];
        const y = state.playerY;

        drawPlayerShip(x, y, color, state.wallet.publicKey, state.playerVelocity);
      }

      // Draw eliminated players as ghosts
      state.multiplayer.remotePlayers.forEach(player => {
        if (player.alive) return;

        const lastPos = player.positionBuffer[player.positionBuffer.length - 1];
        if (!lastPos) return;

        const color = PLAYER_COLORS[player.slot];
        const x = state.width * PLAYER_X_POSITIONS[player.slot];

        // Draw ghost (faded)
        ctx.globalAlpha = 0.3;
        drawPlayerShip(x, lastPos.y, color, null, 0);
        ctx.globalAlpha = 1;
      });

      // Draw local player ghost if eliminated
      if (!state.localPlayer.alive) {
        const color = PLAYER_COLORS[state.localPlayer.slot];
        const x = state.width * PLAYER_X_POSITIONS[state.localPlayer.slot];

        ctx.globalAlpha = 0.3;
        drawPlayerShip(x, state.playerY, color, null, 0);
        ctx.globalAlpha = 1;
      }
    }

    function drawPlayerShip(x, y, color, wallet, velocity) {
      // Glow
      ctx.shadowColor = color.main;
      ctx.shadowBlur = 20;

      // Player body (rocket/ship shape)
      ctx.fillStyle = color.main;
      ctx.beginPath();
      ctx.moveTo(x + PLAYER_SIZE / 2, y);
      ctx.lineTo(x - PLAYER_SIZE / 2, y - PLAYER_SIZE / 3);
      ctx.lineTo(x - PLAYER_SIZE / 3, y);
      ctx.lineTo(x - PLAYER_SIZE / 2, y + PLAYER_SIZE / 3);
      ctx.closePath();
      ctx.fill();

      // Trail effect when moving up
      if (velocity < 0) {
        ctx.fillStyle = color.glow;
        ctx.beginPath();
        ctx.moveTo(x - PLAYER_SIZE / 2, y);
        ctx.lineTo(x - PLAYER_SIZE, y - 5);
        ctx.lineTo(x - PLAYER_SIZE * 1.5, y);
        ctx.lineTo(x - PLAYER_SIZE, y + 5);
        ctx.closePath();
        ctx.fill();
      }

      ctx.shadowBlur = 0;

      // Draw wallet address above player
      if (wallet) {
        ctx.fillStyle = color.main;
        ctx.font = '10px "Space Mono"';
        ctx.textAlign = 'center';
        ctx.fillText(truncateAddress(wallet), x, y - PLAYER_SIZE / 2 - 8);
      }
    }

    function drawIdleVisualization() {
      // Animated price visualization when not playing
      if (state.priceHistory.length > 0) {
        const pulse = Math.sin(Date.now() / 300) * 0.5 + 0.5;
        
        ctx.fillStyle = `rgba(139, 92, 246, ${0.1 + pulse * 0.1})`;
        ctx.beginPath();
        ctx.arc(state.width / 2, state.height / 2, 100 + pulse * 20, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Start the app
    init();
  </script>
</body>
</html>
